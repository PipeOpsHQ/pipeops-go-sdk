{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PipeOps Go SDK","text":"<p>Welcome to the comprehensive documentation for the PipeOps Go SDK - a powerful, production-ready Go client library for interacting with the PipeOps Control Plane API.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\u2705 Complete API Coverage - All API endpoints covered across 18+ service modules</li> <li>\ud83d\udd12 Type-Safe - Strongly typed request/response structures</li> <li>\u26a1 Context Support - All methods support context for cancellation and timeouts</li> <li>\ud83d\udd04 Automatic Retries - Built-in retry logic with exponential backoff</li> <li>\ud83d\ude80 Production-Ready - Optimized HTTP client with connection pooling</li> <li>\u2699\ufe0f Configurable - Flexible configuration via functional options pattern</li> <li>\ud83d\udee1\ufe0f Rate Limit Handling - Automatic detection and typed errors</li> <li>\ud83d\udd10 OAuth 2.0 Support - Full OAuth 2.0 authorization code flow</li> <li>\ud83d\udcdd Logging Support - Optional logger interface for debugging</li> <li>\u2728 Well-Documented - Comprehensive examples and documentation</li> <li>\ud83e\uddea Tested - Unit and integration tests included</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation - Get started quickly</li> <li>Quick Start Guide - Your first API call</li> <li>Authentication - Learn about authentication methods</li> <li>API Services - Explore all available services</li> <li>Examples - See real-world examples</li> </ul>"},{"location":"#at-a-glance","title":"At a Glance","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    // Create client\n    client, _ := pipeops.NewClient(\"\")\n\n    // Login\n    ctx := context.Background()\n    loginResp, _, _ := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    \"your-email@example.com\",\n        Password: \"your-password\",\n    })\n\n    // Set token\n    client.SetToken(loginResp.Data.Token)\n\n    // List projects\n    projects, _, _ := client.Projects.List(ctx, nil)\n    fmt.Printf(\"Found %d projects\\n\", len(projects.Data.Projects))\n}\n</code></pre>"},{"location":"#sdk-services","title":"SDK Services","text":"<p>The SDK is organized into specialized services for different API endpoints:</p> Service Description Auth User authentication, signup, password management OAuth OAuth 2.0 authorization flows Projects Project creation, deployment, and management Servers Server/cluster provisioning and management Environments Environment configuration and management Teams Team collaboration and member management Workspaces Workspace organization and settings Billing Subscription, payment, and invoice management AddOns Marketplace add-on deployment Webhooks Webhook configuration and delivery management Users User profile and settings CloudProviders Cloud provider integration ServiceTokens Service account token management"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>GitHub Issues: Report bugs or request features</li> <li>Contributing: See our Contributing Guide</li> <li>Changelog: View Release Notes</li> </ul>"},{"location":"#license","title":"License","text":"<p>This SDK is distributed under the terms specified in the LICENSE file.</p> <p>Ready to get started? Head over to the Installation Guide to begin using the SDK.</p>"},{"location":"WORKFLOWS/","title":"GitHub Actions Workflows","text":"<p>This document describes the GitHub Actions workflows configured for this repository.</p>"},{"location":"WORKFLOWS/#overview","title":"Overview","text":"<p>The repository uses GitHub Actions for continuous integration, automated testing, and release management.</p>"},{"location":"WORKFLOWS/#workflows","title":"Workflows","text":""},{"location":"WORKFLOWS/#1-ci-workflow-githubworkflowsciyml","title":"1. CI Workflow (<code>.github/workflows/ci.yml</code>)","text":"<p>Triggers: - Push to <code>main</code> or <code>develop</code> branches - Pull requests to <code>main</code> or <code>develop</code> branches</p> <p>Jobs:</p>"},{"location":"WORKFLOWS/#test-job","title":"Test Job","text":"<ul> <li>Matrix Testing: Runs tests on Go versions 1.21, 1.22, and 1.23</li> <li>Steps:</li> <li>Checkout code</li> <li>Set up Go environment</li> <li>Cache Go modules for faster builds</li> <li>Download and verify dependencies</li> <li>Build the project</li> <li>Run <code>go vet</code> for static analysis</li> <li>Check code formatting with <code>go fmt</code></li> <li>Run tests with race detection and coverage</li> <li>Upload coverage to Codecov (Go 1.21 only)</li> </ul>"},{"location":"WORKFLOWS/#lint-job","title":"Lint Job","text":"<ul> <li>Steps:</li> <li>Checkout code</li> <li>Set up Go 1.21 environment</li> <li>Run golangci-lint with configured rules</li> </ul> <p>Purpose: Ensures code quality and compatibility across multiple Go versions.</p>"},{"location":"WORKFLOWS/#2-release-workflow-githubworkflowsreleaseyml","title":"2. Release Workflow (<code>.github/workflows/release.yml</code>)","text":"<p>Triggers: - Push of version tags matching pattern <code>v*.*.*</code> (e.g., <code>v1.0.0</code>, <code>v2.1.3</code>)</p> <p>Jobs:</p>"},{"location":"WORKFLOWS/#release-job","title":"Release Job","text":"<ul> <li>Steps:</li> <li>Checkout code with full git history</li> <li>Set up Go 1.21 environment</li> <li>Cache Go modules</li> <li>Download dependencies</li> <li>Run tests to ensure quality</li> <li>Run GoReleaser to create the release</li> <li>Upload release artifacts</li> </ul> <p>Outputs: - GitHub release with auto-generated changelog - Source code archives (<code>.tar.gz</code>) - Checksums file - Release notes</p> <p>Purpose: Automates the release process when version tags are pushed.</p>"},{"location":"WORKFLOWS/#goreleaser-configuration-goreleaseryml","title":"GoReleaser Configuration (<code>.goreleaser.yml</code>)","text":"<p>GoReleaser is configured to: - Skip binary builds (this is a library, not a standalone application) - Generate organized changelogs grouped by type (features, fixes, etc.) - Create source archives - Calculate checksums - Auto-detect pre-release versions (alpha, beta, rc)</p>"},{"location":"WORKFLOWS/#changelog-groups","title":"Changelog Groups","text":"<ul> <li>Features: Commits starting with <code>feat:</code></li> <li>Bug Fixes: Commits starting with <code>fix:</code></li> <li>Performance Improvements: Commits starting with <code>perf:</code></li> <li>Refactors: Commits starting with <code>refactor:</code></li> <li>Documentation: Commits starting with <code>docs:</code></li> </ul>"},{"location":"WORKFLOWS/#golangci-lint-configuration-golangciyml","title":"golangci-lint Configuration (<code>.golangci.yml</code>)","text":"<p>Enabled linters: - <code>errcheck</code> - Checks for unchecked errors - <code>gosimple</code> - Simplifies code - <code>govet</code> - Reports suspicious constructs - <code>ineffassign</code> - Detects ineffectual assignments - <code>staticcheck</code> - Advanced static analysis - <code>unused</code> - Checks for unused code - <code>gofmt</code> - Checks code formatting - <code>goimports</code> - Checks import formatting - <code>misspell</code> - Finds commonly misspelled words - <code>revive</code> - Fast, configurable linter - <code>unconvert</code> - Removes unnecessary type conversions - <code>unparam</code> - Reports unused function parameters - <code>goconst</code> - Finds repeated strings - <code>gocyclo</code> - Computes cyclomatic complexity - <code>stylecheck</code> - Replacement for golint</p>"},{"location":"WORKFLOWS/#dependabot-configuration-githubdependabotyml","title":"Dependabot Configuration (<code>.github/dependabot.yml</code>)","text":"<p>Updates:</p>"},{"location":"WORKFLOWS/#go-modules","title":"Go Modules","text":"<ul> <li>Frequency: Weekly</li> <li>Directory: Root (<code>/</code>)</li> <li>Open PRs limit: 10</li> <li>Labels: <code>dependencies</code>, <code>go</code></li> </ul>"},{"location":"WORKFLOWS/#github-actions","title":"GitHub Actions","text":"<ul> <li>Frequency: Weekly</li> <li>Directory: Root (<code>/</code>)</li> <li>Open PRs limit: 5</li> <li>Labels: <code>dependencies</code>, <code>github-actions</code></li> </ul> <p>Purpose: Keeps dependencies and GitHub Actions up to date automatically.</p>"},{"location":"WORKFLOWS/#how-to-use","title":"How to Use","text":""},{"location":"WORKFLOWS/#running-ci-locally","title":"Running CI Locally","text":"<p>Before pushing code, you can run the same checks locally:</p> <pre><code># Run all checks\nmake check\n\n# Or run individually\nmake fmt      # Format code\nmake vet      # Run go vet\nmake lint     # Run golangci-lint\nmake test     # Run tests\n</code></pre>"},{"location":"WORKFLOWS/#creating-a-release","title":"Creating a Release","text":"<ol> <li>Ensure all changes are merged to <code>main</code></li> <li>Create and push a version tag:    <pre><code>git tag v1.0.0\ngit push origin v1.0.0\n</code></pre></li> <li>The release workflow will automatically:</li> <li>Run tests</li> <li>Create a GitHub release</li> <li>Generate changelog</li> <li>Upload artifacts</li> </ol> <p>See the release documentation for detailed release instructions.</p>"},{"location":"WORKFLOWS/#testing-release-process","title":"Testing Release Process","text":"<p>Test the release process without publishing:</p> <pre><code># Check GoReleaser configuration\ngoreleaser check\n\n# Create a snapshot release (local only)\nmake release-snapshot\n\n# Test release without publishing\nmake release-test\n</code></pre>"},{"location":"WORKFLOWS/#badges","title":"Badges","text":"<p>The following badges are available in the README:</p> <ul> <li>CI Status: Shows the status of the CI workflow</li> <li>Go Report Card: Code quality grade from goreportcard.com</li> <li>GoDoc: Documentation link</li> <li>License: Repository license information</li> </ul>"},{"location":"WORKFLOWS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"WORKFLOWS/#ci-workflow-fails","title":"CI Workflow Fails","text":"<ol> <li>Check the Actions tab for detailed logs</li> <li>Run the same checks locally with <code>make check</code></li> <li>Ensure all dependencies are up to date with <code>go mod tidy</code></li> </ol>"},{"location":"WORKFLOWS/#linter-errors","title":"Linter Errors","text":"<ol> <li>Run <code>make lint</code> locally to see all errors</li> <li>Use <code>make lint-fix</code> to auto-fix some issues</li> <li>Check <code>.golangci.yml</code> for linter configuration</li> </ol>"},{"location":"WORKFLOWS/#release-workflow-fails","title":"Release Workflow Fails","text":"<ol> <li>Verify tag format is <code>v*.*.*</code> (e.g., <code>v1.0.0</code>)</li> <li>Ensure all tests pass on <code>main</code> branch</li> <li>Check GoReleaser config with <code>goreleaser check</code></li> </ol>"},{"location":"WORKFLOWS/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub Actions Documentation</li> <li>GoReleaser Documentation</li> <li>golangci-lint Documentation</li> <li>Dependabot Documentation</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to the PipeOps Go SDK.</p>"},{"location":"changelog/#latest","title":"Latest","text":"<p>See CHANGELOG.md in the repository.</p>"},{"location":"changelog/#links","title":"Links","text":"<ul> <li>GitHub Releases</li> <li>Release Process</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to the PipeOps Go SDK!</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository</li> <li>Clone your fork</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Run tests</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/PipeOpsHQ/pipeops-go-sdk.git\ncd pipeops-go-sdk\n\n# Install dependencies\ngo mod download\n\n# Run tests\ngo test ./...\n</code></pre>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ul> <li>Follow the existing code style</li> <li>Add tests for new features</li> <li>Update documentation</li> <li>Keep commits focused and descriptive</li> </ul>"},{"location":"contributing/#see-also","title":"See Also","text":"<ul> <li>CONTRIBUTING.md</li> <li>GitHub Repository</li> </ul>"},{"location":"advanced/custom-http-client/","title":"Custom HTTP Client","text":"<p>Use a custom HTTP client for advanced configurations.</p>"},{"location":"advanced/custom-http-client/#basic-custom-client","title":"Basic Custom Client","text":"<pre><code>import (\n    \"net/http\"\n    \"time\"\n)\n\ncustomClient := &amp;http.Client{\n    Timeout: 60 * time.Second,\n}\n\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithHTTPClient(customClient),\n)\n</code></pre>"},{"location":"advanced/custom-http-client/#custom-transport","title":"Custom Transport","text":"<pre><code>transport := &amp;http.Transport{\n    MaxIdleConns:        100,\n    MaxIdleConnsPerHost: 10,\n    IdleConnTimeout:     90 * time.Second,\n}\n\nhttpClient := &amp;http.Client{\n    Transport: transport,\n    Timeout:   60 * time.Second,\n}\n\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithHTTPClient(httpClient),\n)\n</code></pre>"},{"location":"advanced/custom-http-client/#tls-configuration","title":"TLS Configuration","text":"<pre><code>import \"crypto/tls\"\n\ntlsConfig := &amp;tls.Config{\n    MinVersion: tls.VersionTLS12,\n}\n\ntransport := &amp;http.Transport{\n    TLSClientConfig: tlsConfig,\n}\n\nhttpClient := &amp;http.Client{\n    Transport: transport,\n}\n\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithHTTPClient(httpClient),\n)\n</code></pre>"},{"location":"advanced/custom-http-client/#proxy-support","title":"Proxy Support","text":"<pre><code>import \"net/url\"\n\nproxyURL, _ := url.Parse(\"http://proxy.example.com:8080\")\n\ntransport := &amp;http.Transport{\n    Proxy: http.ProxyURL(proxyURL),\n}\n\nhttpClient := &amp;http.Client{\n    Transport: transport,\n}\n\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithHTTPClient(httpClient),\n)\n</code></pre>"},{"location":"advanced/custom-http-client/#see-also","title":"See Also","text":"<ul> <li>Configuration</li> </ul>"},{"location":"advanced/error-handling/","title":"Error Handling","text":"<p>The SDK provides comprehensive error handling with typed errors for common scenarios.</p>"},{"location":"advanced/error-handling/#basic-error-handling","title":"Basic Error Handling","text":"<p>Always check for errors returned by SDK methods:</p> <pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif err != nil {\n    log.Printf(\"API error: %v\", err)\n    return err\n}\n\n// Use the data\nfmt.Printf(\"Projects: %d\\n\", len(projects.Data.Projects))\n</code></pre>"},{"location":"advanced/error-handling/#http-status-codes","title":"HTTP Status Codes","text":"<p>Check HTTP response status:</p> <pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif err != nil {\n    if resp != nil {\n        switch resp.StatusCode {\n        case 400:\n            log.Println(\"Bad request - check parameters\")\n        case 401:\n            log.Println(\"Unauthorized - check authentication token\")\n        case 403:\n            log.Println(\"Forbidden - insufficient permissions\")\n        case 404:\n            log.Println(\"Not found\")\n        case 429:\n            log.Println(\"Rate limited\")\n        case 500:\n            log.Println(\"Server error\")\n        default:\n            log.Printf(\"HTTP error: %d\", resp.StatusCode)\n        }\n    }\n    return err\n}\n</code></pre>"},{"location":"advanced/error-handling/#rate-limit-errors","title":"Rate Limit Errors","text":"<p>Handle rate limiting with typed errors:</p> <pre><code>projects, _, err := client.Projects.List(ctx, nil)\nif err != nil {\n    if rateLimitErr, ok := err.(*pipeops.RateLimitError); ok {\n        fmt.Printf(\"Rate limited. Retry after: %v\\n\", rateLimitErr.RetryAfter)\n\n        // Wait and retry\n        time.Sleep(rateLimitErr.RetryAfter)\n        projects, _, err = client.Projects.List(ctx, nil)\n    }\n}\n</code></pre>"},{"location":"advanced/error-handling/#context-errors","title":"Context Errors","text":"<p>Handle context cancellation and timeouts:</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\n\nprojects, _, err := client.Projects.List(ctx, nil)\nif err != nil {\n    if errors.Is(err, context.DeadlineExceeded) {\n        log.Println(\"Request timed out\")\n    } else if errors.Is(err, context.Canceled) {\n        log.Println(\"Request was canceled\")\n    }\n    return err\n}\n</code></pre>"},{"location":"advanced/error-handling/#retry-logic","title":"Retry Logic","text":"<p>Implement custom retry logic:</p> <pre><code>func listProjectsWithRetry(client *pipeops.Client, ctx context.Context, maxRetries int) (*pipeops.ProjectsResponse, error) {\n    var lastErr error\n\n    for i := 0; i &lt; maxRetries; i++ {\n        projects, resp, err := client.Projects.List(ctx, nil)\n        if err == nil {\n            return projects, nil\n        }\n\n        lastErr = err\n\n        // Don't retry on client errors (4xx)\n        if resp != nil &amp;&amp; resp.StatusCode &gt;= 400 &amp;&amp; resp.StatusCode &lt; 500 {\n            return nil, err\n        }\n\n        // Wait before retry\n        backoff := time.Duration(math.Pow(2, float64(i))) * time.Second\n        time.Sleep(backoff)\n    }\n\n    return nil, fmt.Errorf(\"max retries exceeded: %w\", lastErr)\n}\n</code></pre>"},{"location":"advanced/error-handling/#error-response-structure","title":"Error Response Structure","text":"<p>API error responses follow this structure:</p> <pre><code>type ErrorResponse struct {\n    Response *http.Response\n    Status   string `json:\"status\"`\n    Message  string `json:\"message\"`\n    Errors   map[string][]string `json:\"errors,omitempty\"`\n}\n</code></pre>"},{"location":"advanced/error-handling/#validation-errors","title":"Validation Errors","text":"<p>Handle validation errors:</p> <pre><code>_, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n    Email:    \"invalid-email\",\n    Password: \"pass\",\n})\nif err != nil {\n    if errResp, ok := err.(*pipeops.ErrorResponse); ok {\n        if errResp.Errors != nil {\n            for field, messages := range errResp.Errors {\n                for _, msg := range messages {\n                    fmt.Printf(\"%s: %s\\n\", field, msg)\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"advanced/error-handling/#1-always-check-errors","title":"1. Always Check Errors","text":"<pre><code>// \u2705 Good\nprojects, _, err := client.Projects.List(ctx, nil)\nif err != nil {\n    return err\n}\n\n// \u274c Bad\nprojects, _, _ := client.Projects.List(ctx, nil)\n</code></pre>"},{"location":"advanced/error-handling/#2-provide-context","title":"2. Provide Context","text":"<pre><code>projects, _, err := client.Projects.List(ctx, nil)\nif err != nil {\n    return fmt.Errorf(\"failed to list projects: %w\", err)\n}\n</code></pre>"},{"location":"advanced/error-handling/#3-handle-specific-cases","title":"3. Handle Specific Cases","text":"<pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif err != nil {\n    switch {\n    case resp != nil &amp;&amp; resp.StatusCode == 401:\n        return refreshTokenAndRetry()\n    case resp != nil &amp;&amp; resp.StatusCode == 429:\n        return retryAfterBackoff()\n    default:\n        return err\n    }\n}\n</code></pre>"},{"location":"advanced/error-handling/#see-also","title":"See Also","text":"<ul> <li>Retries &amp; Timeouts</li> <li>Rate Limiting</li> <li>Logging</li> </ul>"},{"location":"advanced/logging/","title":"Logging","text":"<p>Add logging to the SDK for debugging and monitoring.</p>"},{"location":"advanced/logging/#enable-logging","title":"Enable Logging","text":"<p>Implement the Logger interface:</p> <pre><code>import \"log\"\n\ntype MyLogger struct{}\n\nfunc (l *MyLogger) Debug(msg string, keysAndValues ...interface{}) {\n    log.Printf(\"[DEBUG] %s %v\", msg, keysAndValues)\n}\n\nfunc (l *MyLogger) Info(msg string, keysAndValues ...interface{}) {\n    log.Printf(\"[INFO] %s %v\", msg, keysAndValues)\n}\n\nfunc (l *MyLogger) Warn(msg string, keysAndValues ...interface{}) {\n    log.Printf(\"[WARN] %s %v\", msg, keysAndValues)\n}\n\nfunc (l *MyLogger) Error(msg string, keysAndValues ...interface{}) {\n    log.Printf(\"[ERROR] %s %v\", msg, keysAndValues)\n}\n\n// Use the logger\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithLogger(&amp;MyLogger{}),\n)\n</code></pre>"},{"location":"advanced/logging/#structured-logging","title":"Structured Logging","text":"<p>Use structured logging libraries:</p> <pre><code>import \"go.uber.org/zap\"\n\ntype ZapLogger struct {\n    logger *zap.SugaredLogger\n}\n\nfunc (l *ZapLogger) Debug(msg string, keysAndValues ...interface{}) {\n    l.logger.Debugw(msg, keysAndValues...)\n}\n\nfunc (l *ZapLogger) Info(msg string, keysAndValues ...interface{}) {\n    l.logger.Infow(msg, keysAndValues...)\n}\n\nfunc (l *ZapLogger) Warn(msg string, keysAndValues ...interface{}) {\n    l.logger.Warnw(msg, keysAndValues...)\n}\n\nfunc (l *ZapLogger) Error(msg string, keysAndValues ...interface{}) {\n    l.logger.Errorw(msg, keysAndValues...)\n}\n\n// Create logger\nzapLogger, _ := zap.NewProduction()\nlogger := &amp;ZapLogger{logger: zapLogger.Sugar()}\n\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithLogger(logger),\n)\n</code></pre>"},{"location":"advanced/logging/#log-levels","title":"Log Levels","text":"<p>Control log verbosity:</p> <pre><code>type LeveledLogger struct {\n    level string\n}\n\nfunc (l *LeveledLogger) Debug(msg string, keysAndValues ...interface{}) {\n    if l.level == \"debug\" {\n        log.Printf(\"[DEBUG] %s\", msg)\n    }\n}\n\nfunc (l *LeveledLogger) Info(msg string, keysAndValues ...interface{}) {\n    if l.level == \"debug\" || l.level == \"info\" {\n        log.Printf(\"[INFO] %s\", msg)\n    }\n}\n</code></pre>"},{"location":"advanced/logging/#see-also","title":"See Also","text":"<ul> <li>Error Handling</li> <li>Configuration</li> </ul>"},{"location":"advanced/rate-limiting/","title":"Rate Limiting","text":"<p>Handle API rate limits effectively with the SDK.</p>"},{"location":"advanced/rate-limiting/#rate-limit-detection","title":"Rate Limit Detection","text":"<p>The SDK automatically detects rate limit errors (HTTP 429):</p> <pre><code>projects, _, err := client.Projects.List(ctx, nil)\nif rateLimitErr, ok := err.(*pipeops.RateLimitError); ok {\n    fmt.Printf(\"Rate limited. Retry after: %v\\n\", rateLimitErr.RetryAfter)\n}\n</code></pre>"},{"location":"advanced/rate-limiting/#automatic-retry","title":"Automatic Retry","text":"<p>The SDK automatically retries rate-limited requests:</p> <pre><code>// Automatically handles rate limits with exponential backoff\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithMaxRetries(5),\n)\n\nprojects, _, err := client.Projects.List(ctx, nil)\n</code></pre>"},{"location":"advanced/rate-limiting/#manual-rate-limit-handling","title":"Manual Rate Limit Handling","text":"<p>Handle rate limits explicitly:</p> <pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif err != nil {\n    if resp != nil &amp;&amp; resp.StatusCode == 429 {\n        // Get retry-after header\n        retryAfter := resp.Header.Get(\"Retry-After\")\n        if retryAfter != \"\" {\n            seconds, _ := strconv.Atoi(retryAfter)\n            time.Sleep(time.Duration(seconds) * time.Second)\n\n            // Retry\n            projects, _, err = client.Projects.List(ctx, nil)\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/rate-limiting/#rate-limit-headers","title":"Rate Limit Headers","text":"<p>Check rate limit headers:</p> <pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif resp != nil {\n    limit := resp.Header.Get(\"X-RateLimit-Limit\")\n    remaining := resp.Header.Get(\"X-RateLimit-Remaining\")\n    reset := resp.Header.Get(\"X-RateLimit-Reset\")\n\n    fmt.Printf(\"Rate Limit: %s/%s (resets at %s)\\n\", remaining, limit, reset)\n}\n</code></pre>"},{"location":"advanced/rate-limiting/#best-practices","title":"Best Practices","text":""},{"location":"advanced/rate-limiting/#1-implement-backoff","title":"1. Implement Backoff","text":"<pre><code>func makeRequestWithBackoff(ctx context.Context) error {\n    backoff := 1 * time.Second\n    maxBackoff := 60 * time.Second\n\n    for {\n        _, resp, err := client.Projects.List(ctx, nil)\n        if err == nil {\n            return nil\n        }\n\n        if resp != nil &amp;&amp; resp.StatusCode == 429 {\n            time.Sleep(backoff)\n            backoff = time.Duration(math.Min(\n                float64(backoff*2),\n                float64(maxBackoff),\n            ))\n            continue\n        }\n\n        return err\n    }\n}\n</code></pre>"},{"location":"advanced/rate-limiting/#2-use-token-bucket-pattern","title":"2. Use Token Bucket Pattern","text":"<pre><code>type RateLimiter struct {\n    tokens chan struct{}\n}\n\nfunc NewRateLimiter(rate int) *RateLimiter {\n    rl := &amp;RateLimiter{\n        tokens: make(chan struct{}, rate),\n    }\n\n    // Refill tokens\n    go func() {\n        ticker := time.NewTicker(time.Second / time.Duration(rate))\n        for range ticker.C {\n            select {\n            case rl.tokens &lt;- struct{}{}:\n            default:\n            }\n        }\n    }()\n\n    return rl\n}\n\nfunc (rl *RateLimiter) Wait(ctx context.Context) error {\n    select {\n    case &lt;-rl.tokens:\n        return nil\n    case &lt;-ctx.Done():\n        return ctx.Err()\n    }\n}\n</code></pre>"},{"location":"advanced/rate-limiting/#3-monitor-usage","title":"3. Monitor Usage","text":"<pre><code>type RateLimitMonitor struct {\n    requests  int\n    limit     int\n    remaining int\n    reset     time.Time\n}\n\nfunc (m *RateLimitMonitor) Update(resp *http.Response) {\n    m.requests++\n    if resp != nil {\n        // Parse headers\n        limit, _ := strconv.Atoi(resp.Header.Get(\"X-RateLimit-Limit\"))\n        remaining, _ := strconv.Atoi(resp.Header.Get(\"X-RateLimit-Remaining\"))\n\n        m.limit = limit\n        m.remaining = remaining\n    }\n}\n\nfunc (m *RateLimitMonitor) ShouldWait() bool {\n    return m.remaining &lt; 10 // Conservative threshold\n}\n</code></pre>"},{"location":"advanced/rate-limiting/#see-also","title":"See Also","text":"<ul> <li>Error Handling</li> <li>Retries &amp; Timeouts</li> </ul>"},{"location":"advanced/retries-timeouts/","title":"Retries &amp; Timeouts","text":"<p>Configure automatic retries and timeouts for robust API interactions.</p>"},{"location":"advanced/retries-timeouts/#timeout-configuration","title":"Timeout Configuration","text":""},{"location":"advanced/retries-timeouts/#client-level-timeout","title":"Client-Level Timeout","text":"<p>Set timeout when creating the client:</p> <pre><code>client, err := pipeops.NewClient(\"\",\n    pipeops.WithTimeout(30*time.Second),\n)\n</code></pre>"},{"location":"advanced/retries-timeouts/#request-level-timeout","title":"Request-Level Timeout","text":"<p>Set timeout per request using context:</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\n\nprojects, _, err := client.Projects.List(ctx, nil)\nif errors.Is(err, context.DeadlineExceeded) {\n    log.Println(\"Request timed out\")\n}\n</code></pre>"},{"location":"advanced/retries-timeouts/#retry-configuration","title":"Retry Configuration","text":""},{"location":"advanced/retries-timeouts/#client-level-retries","title":"Client-Level Retries","text":"<p>Configure automatic retries:</p> <pre><code>client, err := pipeops.NewClient(\"\",\n    pipeops.WithMaxRetries(5),\n)\n</code></pre> <p>The SDK automatically retries: - Network errors - HTTP 5xx errors - HTTP 429 rate limit errors</p>"},{"location":"advanced/retries-timeouts/#exponential-backoff","title":"Exponential Backoff","text":"<p>Retries use exponential backoff with jitter:</p> <pre><code>Attempt 1: Wait 100ms-500ms\nAttempt 2: Wait 200ms-1s\nAttempt 3: Wait 400ms-2s\n...\n</code></pre>"},{"location":"advanced/retries-timeouts/#custom-retry-logic","title":"Custom Retry Logic","text":"<p>Implement custom retry logic:</p> <pre><code>func retryWithBackoff(fn func() error, maxRetries int) error {\n    for i := 0; i &lt; maxRetries; i++ {\n        err := fn()\n        if err == nil {\n            return nil\n        }\n\n        // Calculate backoff\n        waitTime := time.Duration(math.Pow(2, float64(i))) * 100 * time.Millisecond\n        jitter := time.Duration(rand.Int63n(int64(waitTime)))\n\n        time.Sleep(waitTime + jitter)\n    }\n\n    return fmt.Errorf(\"max retries exceeded\")\n}\n\n// Usage\nerr := retryWithBackoff(func() error {\n    _, _, err := client.Projects.Deploy(ctx, projectUUID)\n    return err\n}, 5)\n</code></pre>"},{"location":"advanced/retries-timeouts/#timeout-strategies","title":"Timeout Strategies","text":""},{"location":"advanced/retries-timeouts/#short-timeout-for-health-checks","title":"Short Timeout for Health Checks","text":"<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\nhealth, _, _ := client.Misc.HealthCheck(ctx)\n</code></pre>"},{"location":"advanced/retries-timeouts/#long-timeout-for-deployments","title":"Long Timeout for Deployments","text":"<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)\ndefer cancel()\n\ndeployment, _, err := client.Projects.Deploy(ctx, projectUUID)\n</code></pre>"},{"location":"advanced/retries-timeouts/#progressive-timeout","title":"Progressive Timeout","text":"<p>Increase timeout on retries:</p> <pre><code>func requestWithProgressiveTimeout(attempt int) error {\n    timeout := time.Duration(5+attempt*5) * time.Second\n    ctx, cancel := context.WithTimeout(context.Background(), timeout)\n    defer cancel()\n\n    _, _, err := client.Projects.List(ctx, nil)\n    return err\n}\n</code></pre>"},{"location":"advanced/retries-timeouts/#best-practices","title":"Best Practices","text":""},{"location":"advanced/retries-timeouts/#1-set-appropriate-timeouts","title":"1. Set Appropriate Timeouts","text":"<pre><code>// Quick reads\nctx, _ := context.WithTimeout(ctx, 10*time.Second)\n\n// Long operations\nctx, _ := context.WithTimeout(ctx, 5*time.Minute)\n</code></pre>"},{"location":"advanced/retries-timeouts/#2-dont-retry-indefinitely","title":"2. Don't Retry Indefinitely","text":"<pre><code>// \u2705 Good - Limited retries\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithMaxRetries(5),\n)\n\n// \u274c Bad - Infinite retries\nfor {\n    _, _, err := client.Projects.List(ctx, nil)\n    if err == nil {\n        break\n    }\n}\n</code></pre>"},{"location":"advanced/retries-timeouts/#3-use-exponential-backoff","title":"3. Use Exponential Backoff","text":"<pre><code>for i := 0; i &lt; maxRetries; i++ {\n    _, _, err := client.Projects.List(ctx, nil)\n    if err == nil {\n        break\n    }\n\n    // Exponential backoff\n    time.Sleep(time.Duration(1&lt;&lt;i) * time.Second)\n}\n</code></pre>"},{"location":"advanced/retries-timeouts/#see-also","title":"See Also","text":"<ul> <li>Error Handling</li> <li>Rate Limiting</li> </ul>"},{"location":"api-services/addons/","title":"Add-ons Service","text":"<p>The Add-ons Service manages marketplace add-on deployments.</p>"},{"location":"api-services/addons/#overview","title":"Overview","text":"<pre><code>// Access the add-ons service\naddonsService := client.AddOns\n</code></pre>"},{"location":"api-services/addons/#methods","title":"Methods","text":""},{"location":"api-services/addons/#list-add-ons","title":"List Add-ons","text":"<p>List available add-ons:</p> <pre><code>addons, _, err := client.AddOns.List(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list add-ons: %v\", err)\n}\n\nfor _, addon := range addons.Data.AddOns {\n    fmt.Printf(\"- %s: %s\\n\", addon.Name, addon.Description)\n}\n</code></pre>"},{"location":"api-services/addons/#get-add-on","title":"Get Add-on","text":"<p>Get specific add-on details:</p> <pre><code>addon, _, err := client.AddOns.Get(ctx, \"addon-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get add-on: %v\", err)\n}\n\nfmt.Printf(\"Add-on: %s\\n\", addon.Data.AddOn.Name)\nfmt.Printf(\"Version: %s\\n\", addon.Data.AddOn.Version)\n</code></pre>"},{"location":"api-services/addons/#deploy-add-on","title":"Deploy Add-on","text":"<p>Deploy an add-on:</p> <pre><code>deployment, _, err := client.AddOns.Deploy(ctx, &amp;pipeops.DeployAddOnRequest{\n    AddOnUUID:   \"addon-uuid\",\n    ProjectUUID: \"project-uuid\",\n    Config: map[string]interface{}{\n        \"memory\": \"512Mi\",\n        \"cpu\":    \"250m\",\n    },\n})\nif err != nil {\n    log.Fatalf(\"Deployment failed: %v\", err)\n}\n\nfmt.Printf(\"Deployed: %s\\n\", deployment.Data.Deployment.UUID)\n</code></pre>"},{"location":"api-services/addons/#list-deployments","title":"List Deployments","text":"<p>List add-on deployments:</p> <pre><code>deployments, _, err := client.AddOns.ListDeployments(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list deployments: %v\", err)\n}\n\nfor _, deployment := range deployments.Data.Deployments {\n    fmt.Printf(\"- %s: %s\\n\", deployment.Name, deployment.Status)\n}\n</code></pre>"},{"location":"api-services/addons/#get-deployment","title":"Get Deployment","text":"<p>Get deployment details:</p> <pre><code>deployment, _, err := client.AddOns.GetDeployment(ctx, \"deployment-uuid\")\n</code></pre>"},{"location":"api-services/addons/#update-deployment","title":"Update Deployment","text":"<p>Update deployment configuration:</p> <pre><code>updated, _, err := client.AddOns.UpdateDeployment(ctx, deploymentUUID, &amp;pipeops.UpdateDeploymentRequest{\n    Config: map[string]interface{}{\n        \"replicas\": 3,\n    },\n})\n</code></pre>"},{"location":"api-services/addons/#delete-deployment","title":"Delete Deployment","text":"<p>Delete an add-on deployment:</p> <pre><code>_, err := client.AddOns.DeleteDeployment(ctx, \"deployment-uuid\")\n</code></pre>"},{"location":"api-services/addons/#sync-deployment","title":"Sync Deployment","text":"<p>Sync deployment state:</p> <pre><code>_, err := client.AddOns.SyncDeployment(ctx, \"deployment-uuid\")\n</code></pre>"},{"location":"api-services/addons/#list-categories","title":"List Categories","text":"<p>List add-on categories:</p> <pre><code>categories, _, err := client.AddOns.ListCategories(ctx)\n</code></pre>"},{"location":"api-services/addons/#submit-add-on","title":"Submit Add-on","text":"<p>Submit an add-on to marketplace:</p> <pre><code>submission, _, err := client.AddOns.SubmitAddOn(ctx, &amp;pipeops.AddOnSubmissionRequest{\n    Name:        \"My Add-on\",\n    Description: \"A useful add-on\",\n    Version:     \"1.0.0\",\n    Category:    \"database\",\n})\n</code></pre>"},{"location":"api-services/addons/#see-also","title":"See Also","text":"<ul> <li>Projects Service</li> </ul>"},{"location":"api-services/auth/","title":"Authentication Service","text":"<p>The Authentication Service handles user authentication, account management, and password operations.</p>"},{"location":"api-services/auth/#overview","title":"Overview","text":"<pre><code>// Access the authentication service\nauthService := client.Auth\n</code></pre> <p>Note: This page documents the Auth service API methods. For authentication guides and best practices, see: - Authentication Overview - Basic Authentication Guide</p>"},{"location":"api-services/auth/#methods","title":"Methods","text":""},{"location":"api-services/auth/#login","title":"Login","text":"<p>Authenticate with email and password:</p> <pre><code>resp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n    Email:    \"user@example.com\",\n    Password: \"your-password\",\n})\nif err != nil {\n    log.Fatalf(\"Login failed: %v\", err)\n}\n\n// Set token for authenticated requests\nclient.SetToken(resp.Data.Token)\nfmt.Printf(\"Logged in as: %s\\n\", resp.Data.User.Email)\n</code></pre>"},{"location":"api-services/auth/#signup","title":"Signup","text":"<p>Create a new user account:</p> <pre><code>resp, _, err := client.Auth.Signup(ctx, &amp;pipeops.SignupRequest{\n    Email:     \"newuser@example.com\",\n    Password:  \"secure-password\",\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n})\nif err != nil {\n    log.Fatalf(\"Signup failed: %v\", err)\n}\n\nfmt.Printf(\"Account created: %s\\n\", resp.Data.User.Email)\n</code></pre>"},{"location":"api-services/auth/#change-password","title":"Change Password","text":"<p>Change the authenticated user's password:</p> <pre><code>// Must be authenticated\nclient.SetToken(userToken)\n\nresp, _, err := client.Auth.ChangePassword(ctx, &amp;pipeops.ChangePasswordRequest{\n    OldPassword: \"current-password\",\n    NewPassword: \"new-password\",\n})\nif err != nil {\n    log.Fatalf(\"Password change failed: %v\", err)\n}\n\nfmt.Println(\"Password changed successfully\")\n</code></pre>"},{"location":"api-services/auth/#request-password-reset","title":"Request Password Reset","text":"<p>Send a password reset email:</p> <pre><code>resp, _, err := client.Auth.RequestPasswordReset(ctx, &amp;pipeops.PasswordResetRequest{\n    Email: \"user@example.com\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to request reset: %v\", err)\n}\n\nfmt.Println(\"Password reset email sent\")\n</code></pre>"},{"location":"api-services/auth/#reset-password","title":"Reset Password","text":"<p>Complete password reset with token from email:</p> <pre><code>resp, err := client.Auth.ResetPassword(ctx, &amp;pipeops.ResetPasswordRequest{\n    Token:       \"reset-token-from-email\",\n    NewPassword: \"new-password\",\n})\nif err != nil {\n    log.Fatalf(\"Password reset failed: %v\", err)\n}\n\nfmt.Println(\"Password reset successful\")\n</code></pre>"},{"location":"api-services/auth/#verify-password-reset-token","title":"Verify Password Reset Token","text":"<p>Check if a reset token is valid:</p> <pre><code>resp, err := client.Auth.VerifyPasswordResetToken(ctx, \"token-from-email\")\nif err != nil {\n    log.Println(\"Token is invalid or expired\")\n} else {\n    fmt.Println(\"Token is valid\")\n}\n</code></pre>"},{"location":"api-services/auth/#activate-email","title":"Activate Email","text":"<p>Activate user email with token:</p> <pre><code>resp, err := client.Auth.ActivateEmail(ctx, &amp;pipeops.ActivateEmailRequest{\n    Token: \"activation-token-from-email\",\n})\nif err != nil {\n    log.Fatalf(\"Email activation failed: %v\", err)\n}\n\nfmt.Println(\"Email activated successfully\")\n</code></pre>"},{"location":"api-services/auth/#verify-login-2fa","title":"Verify Login (2FA)","text":"<p>Verify login with two-factor authentication code:</p> <pre><code>resp, _, err := client.Auth.VerifyLogin(ctx, &amp;pipeops.VerifyLoginRequest{\n    Email: \"user@example.com\",\n    Code:  \"123456\", // 2FA code\n})\nif err != nil {\n    log.Fatalf(\"2FA verification failed: %v\", err)\n}\n\nclient.SetToken(resp.Data.Token)\nfmt.Println(\"2FA verification successful\")\n</code></pre>"},{"location":"api-services/auth/#oauth-signup","title":"OAuth Signup","text":"<p>Initiate OAuth signup with a provider:</p> <pre><code>resp, err := client.Auth.OAuthSignup(ctx, \"google\")\nif err != nil {\n    log.Fatalf(\"OAuth signup failed: %v\", err)\n}\n\n// Redirects to OAuth provider\n</code></pre>"},{"location":"api-services/auth/#oauth-callback","title":"OAuth Callback","text":"<p>Handle OAuth callback after authorization:</p> <pre><code>resp, _, err := client.Auth.OAuthCallback(ctx, \"google\")\nif err != nil {\n    log.Fatalf(\"OAuth callback failed: %v\", err)\n}\n\nclient.SetToken(resp.Data.Token)\nfmt.Printf(\"Authenticated via OAuth: %s\\n\", resp.Data.User.Email)\n</code></pre>"},{"location":"api-services/auth/#data-types","title":"Data Types","text":""},{"location":"api-services/auth/#loginrequest","title":"LoginRequest","text":"<pre><code>type LoginRequest struct {\n    Email    string `json:\"email\"`\n    Password string `json:\"password\"`\n}\n</code></pre>"},{"location":"api-services/auth/#signuprequest","title":"SignupRequest","text":"<pre><code>type SignupRequest struct {\n    Email     string `json:\"email\"`\n    Password  string `json:\"password\"`\n    FirstName string `json:\"first_name,omitempty\"`\n    LastName  string `json:\"last_name,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/auth/#user","title":"User","text":"<pre><code>type User struct {\n    ID            string     `json:\"id,omitempty\"`\n    UUID          string     `json:\"uuid,omitempty\"`\n    Email         string     `json:\"email,omitempty\"`\n    FirstName     string     `json:\"first_name,omitempty\"`\n    LastName      string     `json:\"last_name,omitempty\"`\n    IsActive      bool       `json:\"is_active,omitempty\"`\n    EmailVerified bool       `json:\"email_verified,omitempty\"`\n    CreatedAt     *Timestamp `json:\"created_at,omitempty\"`\n    UpdatedAt     *Timestamp `json:\"updated_at,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/auth/#complete-example","title":"Complete Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n    ctx := context.Background()\n\n    // Get credentials from environment\n    email := os.Getenv(\"PIPEOPS_EMAIL\")\n    password := os.Getenv(\"PIPEOPS_PASSWORD\")\n\n    // Login\n    loginResp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    email,\n        Password: password,\n    })\n    if err != nil {\n        log.Fatalf(\"Login failed: %v\", err)\n    }\n\n    fmt.Printf(\"Successfully logged in as: %s\\n\", loginResp.Data.User.Email)\n    fmt.Printf(\"User ID: %s\\n\", loginResp.Data.User.UUID)\n    fmt.Printf(\"Email Verified: %t\\n\", loginResp.Data.User.EmailVerified)\n\n    // Set token for future requests\n    client.SetToken(loginResp.Data.Token)\n\n    // Now you can make authenticated API calls\n    projects, _, _ := client.Projects.List(ctx, nil)\n    fmt.Printf(\"Found %d projects\\n\", len(projects.Data.Projects))\n}\n</code></pre>"},{"location":"api-services/auth/#see-also","title":"See Also","text":"<ul> <li>Authentication Overview</li> <li>Basic Authentication</li> <li>OAuth 2.0</li> <li>Users Service - Manage user profile and settings</li> </ul>"},{"location":"api-services/billing/","title":"Billing Service","text":"<p>The Billing Service manages subscriptions, payments, and invoices.</p>"},{"location":"api-services/billing/#overview","title":"Overview","text":"<pre><code>// Access the billing service\nbillingService := client.Billing\n</code></pre>"},{"location":"api-services/billing/#methods","title":"Methods","text":""},{"location":"api-services/billing/#get-balance","title":"Get Balance","text":"<p>Get current account balance:</p> <pre><code>balance, _, err := client.Billing.GetBalance(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to get balance: %v\", err)\n}\n\nfmt.Printf(\"Balance: $%.2f\\n\", balance.Data.Balance)\nfmt.Printf(\"Credit: $%.2f\\n\", balance.Data.Credit)\n</code></pre>"},{"location":"api-services/billing/#list-invoices","title":"List Invoices","text":"<p>List all invoices:</p> <pre><code>invoices, _, err := client.Billing.ListInvoices(ctx, &amp;pipeops.InvoiceListOptions{\n    Page:  1,\n    Limit: 20,\n})\nif err != nil {\n    log.Fatalf(\"Failed to list invoices: %v\", err)\n}\n\nfor _, invoice := range invoices.Data.Invoices {\n    fmt.Printf(\"Invoice: %s - $%.2f - %s\\n\", \n        invoice.ID, invoice.Amount, invoice.Status)\n}\n</code></pre>"},{"location":"api-services/billing/#get-invoice","title":"Get Invoice","text":"<p>Get specific invoice:</p> <pre><code>invoice, _, err := client.Billing.GetInvoice(ctx, \"invoice-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get invoice: %v\", err)\n}\n\nfmt.Printf(\"Amount: $%.2f\\n\", invoice.Data.Invoice.Amount)\n</code></pre>"},{"location":"api-services/billing/#add-payment-card","title":"Add Payment Card","text":"<p>Add a payment method:</p> <pre><code>card, _, err := client.Billing.AddCard(ctx, &amp;pipeops.AddCardRequest{\n    Token: \"stripe-card-token\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to add card: %v\", err)\n}\n\nfmt.Printf(\"Card added: ****%s\\n\", card.Data.Card.Last4)\n</code></pre>"},{"location":"api-services/billing/#get-active-card","title":"Get Active Card","text":"<p>Get the active payment card:</p> <pre><code>card, _, err := client.Billing.GetActiveCard(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to get card: %v\", err)\n}\n\nfmt.Printf(\"Active card: ****%s\\n\", card.Data.Card.Last4)\n</code></pre>"},{"location":"api-services/billing/#delete-card","title":"Delete Card","text":"<p>Remove a payment card:</p> <pre><code>_, err := client.Billing.DeleteCard(ctx, \"card-uuid\")\n</code></pre>"},{"location":"api-services/billing/#add-credit","title":"Add Credit","text":"<p>Add credit to account:</p> <pre><code>credit, _, err := client.Billing.AddCredit(ctx, &amp;pipeops.CreditRequest{\n    Amount: 100.00,\n})\n</code></pre>"},{"location":"api-services/billing/#apply-discount","title":"Apply Discount","text":"<p>Apply a discount code:</p> <pre><code>_, err := client.Billing.ApplyDiscount(ctx, &amp;pipeops.ApplyDiscountRequest{\n    Code: \"DISCOUNT20\",\n})\n</code></pre>"},{"location":"api-services/billing/#get-subscription","title":"Get Subscription","text":"<p>Get current subscription details:</p> <pre><code>subscription, _, err := client.Billing.GetSubscription(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to get subscription: %v\", err)\n}\n\nfmt.Printf(\"Plan: %s\\n\", subscription.Data.Subscription.Plan)\nfmt.Printf(\"Status: %s\\n\", subscription.Data.Subscription.Status)\n</code></pre>"},{"location":"api-services/billing/#cancel-subscription","title":"Cancel Subscription","text":"<p>Cancel an active subscription:</p> <pre><code>_, err := client.Billing.CancelSubscription(ctx, \"subscription-uuid\")\n</code></pre>"},{"location":"api-services/billing/#export-invoices","title":"Export Invoices","text":"<p>Export invoices in various formats:</p> <pre><code>export, _, err := client.Billing.ExportInvoices(ctx, &amp;pipeops.ExportInvoicesRequest{\n    Format:    \"pdf\",\n    StartDate: \"2024-01-01\",\n    EndDate:   \"2024-12-31\",\n})\n</code></pre>"},{"location":"api-services/billing/#complete-example","title":"Complete Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n    client.SetToken(\"your-token\")\n\n    ctx := context.Background()\n\n    // Get current balance\n    balance, _, err := client.Billing.GetBalance(ctx)\n    if err != nil {\n        log.Fatalf(\"Failed to get balance: %v\", err)\n    }\n\n    fmt.Printf(\"Account Balance: $%.2f\\n\", balance.Data.Balance)\n\n    // List recent invoices\n    invoices, _, err := client.Billing.ListInvoices(ctx, &amp;pipeops.InvoiceListOptions{\n        Limit: 5,\n    })\n    if err != nil {\n        log.Fatalf(\"Failed to list invoices: %v\", err)\n    }\n\n    fmt.Printf(\"\\nRecent Invoices:\\n\")\n    for _, invoice := range invoices.Data.Invoices {\n        fmt.Printf(\"- %s: $%.2f (%s)\\n\", \n            invoice.Date, invoice.Amount, invoice.Status)\n    }\n}\n</code></pre>"},{"location":"api-services/billing/#see-also","title":"See Also","text":"<ul> <li>Workspaces Service</li> </ul>"},{"location":"api-services/cloudproviders/","title":"Cloud Providers Service","text":"<p>The Cloud Providers Service manages cloud provider integrations.</p>"},{"location":"api-services/cloudproviders/#overview","title":"Overview","text":"<pre><code>// Access the cloud providers service\ncloudProvidersService := client.CloudProviders\n</code></pre>"},{"location":"api-services/cloudproviders/#methods","title":"Methods","text":""},{"location":"api-services/cloudproviders/#list-cloud-providers","title":"List Cloud Providers","text":"<p>List available cloud providers:</p> <pre><code>providers, _, err := client.CloudProviders.List(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list providers: %v\", err)\n}\n\nfor _, provider := range providers.Data.Providers {\n    fmt.Printf(\"- %s: %s\\n\", provider.Name, provider.Status)\n}\n</code></pre>"},{"location":"api-services/cloudproviders/#connect-provider","title":"Connect Provider","text":"<p>Connect a cloud provider account:</p> <pre><code>connection, _, err := client.CloudProviders.Connect(ctx, &amp;pipeops.ConnectProviderRequest{\n    Provider:    \"aws\",\n    Credentials: map[string]string{\n        \"access_key\": \"AKIAIOSFODNN7EXAMPLE\",\n        \"secret_key\": \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\",\n    },\n    Region: \"us-east-1\",\n})\n</code></pre>"},{"location":"api-services/cloudproviders/#list-regions","title":"List Regions","text":"<p>List available regions for a provider:</p> <pre><code>regions, _, err := client.CloudProviders.ListRegions(ctx, \"aws\")\n</code></pre>"},{"location":"api-services/cloudproviders/#see-also","title":"See Also","text":"<ul> <li>Servers Service</li> </ul>"},{"location":"api-services/environments/","title":"Environments Service","text":"<p>The Environments Service manages environment configurations for projects.</p>"},{"location":"api-services/environments/#overview","title":"Overview","text":"<pre><code>// Access the environments service\nenvironmentsService := client.Environments\n</code></pre>"},{"location":"api-services/environments/#methods","title":"Methods","text":""},{"location":"api-services/environments/#list-environments","title":"List Environments","text":"<p>List all environments:</p> <pre><code>environments, _, err := client.Environments.List(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list environments: %v\", err)\n}\n\nfor _, env := range environments.Data.Environments {\n    fmt.Printf(\"- %s (%s)\\n\", env.Name, env.UUID)\n}\n</code></pre>"},{"location":"api-services/environments/#get-environment","title":"Get Environment","text":"<p>Get a specific environment:</p> <pre><code>env, _, err := client.Environments.Get(ctx, \"environment-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get environment: %v\", err)\n}\n\nfmt.Printf(\"Environment: %s\\n\", env.Data.Environment.Name)\n</code></pre>"},{"location":"api-services/environments/#data-types","title":"Data Types","text":"<pre><code>type Environment struct {\n    ID   string `json:\"id,omitempty\"`\n    UUID string `json:\"uuid,omitempty\"`\n    Name string `json:\"name,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/environments/#see-also","title":"See Also","text":"<ul> <li>Projects Service</li> <li>Servers Service</li> </ul>"},{"location":"api-services/misc/","title":"Miscellaneous Service","text":"<p>The Misc Service provides various utility endpoints.</p>"},{"location":"api-services/misc/#overview","title":"Overview","text":"<pre><code>// Access the misc service\nmiscService := client.Misc\n</code></pre>"},{"location":"api-services/misc/#methods","title":"Methods","text":""},{"location":"api-services/misc/#health-check","title":"Health Check","text":"<p>Check API health:</p> <pre><code>health, _, err := client.Misc.HealthCheck(ctx)\nif err != nil {\n    log.Fatalf(\"Health check failed: %v\", err)\n}\n\nfmt.Printf(\"Status: %s\\n\", health.Status)\n</code></pre>"},{"location":"api-services/misc/#get-version","title":"Get Version","text":"<p>Get API version information:</p> <pre><code>version, _, err := client.Misc.GetVersion(ctx)\nfmt.Printf(\"API Version: %s\\n\", version.Data.Version)\n</code></pre>"},{"location":"api-services/misc/#see-also","title":"See Also","text":"<ul> <li>API Services Overview</li> </ul>"},{"location":"api-services/overview/","title":"API Services Overview","text":"<p>The PipeOps Go SDK is organized into specialized services, each handling a specific area of the PipeOps API. This modular approach makes it easy to discover and use the functionality you need.</p>"},{"location":"api-services/overview/#available-services","title":"Available Services","text":"Service Description Documentation Auth User authentication, signup, password management Guide OAuth OAuth 2.0 authorization flows OAuth Guide Projects Project creation, deployment, and management Guide Servers Server/cluster provisioning and management Guide Environments Environment configuration and management Guide Teams Team collaboration and member management Guide Workspaces Workspace organization and settings Guide Billing Subscription, payment, and invoice management Guide AddOns Marketplace add-on deployment Guide Webhooks Webhook configuration and delivery management Guide Users User profile and settings Guide CloudProviders Cloud provider integration Guide ServiceTokens Service account token management Guide Misc Miscellaneous utilities Guide"},{"location":"api-services/overview/#service-architecture","title":"Service Architecture","text":"<p>All services follow a consistent pattern:</p> <pre><code>// Access services through the client\nclient, _ := pipeops.NewClient(\"\")\nclient.SetToken(\"your-token\")\n\n// Each service has its own methods\nprojects, _, err := client.Projects.List(ctx, nil)\nservers, _, err := client.Servers.List(ctx)\nteams, _, err := client.Teams.List(ctx)\n</code></pre>"},{"location":"api-services/overview/#common-patterns","title":"Common Patterns","text":""},{"location":"api-services/overview/#context-usage","title":"Context Usage","text":"<p>All service methods require a context parameter:</p> <pre><code>ctx := context.Background()\n\n// With timeout\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\nprojects, _, err := client.Projects.List(ctx, nil)\n</code></pre>"},{"location":"api-services/overview/#return-values","title":"Return Values","text":"<p>Most methods return three values:</p> <pre><code>data, response, err := client.Projects.Get(ctx, \"project-id\")\n\n// data: Typed response data\n// response: Raw *http.Response\n// err: Error if any\n</code></pre>"},{"location":"api-services/overview/#options-and-filters","title":"Options and Filters","text":"<p>Many list methods accept options for filtering and pagination:</p> <pre><code>projects, _, err := client.Projects.List(ctx, &amp;pipeops.ProjectListOptions{\n    WorkspaceID: \"workspace-uuid\",\n    Page:        1,\n    Limit:       20,\n})\n</code></pre>"},{"location":"api-services/overview/#error-handling","title":"Error Handling","text":"<p>Always check for errors:</p> <pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif err != nil {\n    if resp != nil &amp;&amp; resp.StatusCode == 401 {\n        log.Println(\"Authentication required\")\n    }\n    return err\n}\n</code></pre>"},{"location":"api-services/overview/#quick-examples-by-service","title":"Quick Examples by Service","text":""},{"location":"api-services/overview/#authentication","title":"Authentication","text":"<pre><code>// Login\nloginResp, _, _ := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n    Email:    \"user@example.com\",\n    Password: \"password\",\n})\nclient.SetToken(loginResp.Data.Token)\n</code></pre>"},{"location":"api-services/overview/#projects","title":"Projects","text":"<pre><code>// List projects\nprojects, _, _ := client.Projects.List(ctx, nil)\n\n// Get specific project\nproject, _, _ := client.Projects.Get(ctx, \"project-uuid\")\n\n// Create project\nnewProject, _, _ := client.Projects.Create(ctx, &amp;pipeops.CreateProjectRequest{\n    Name:       \"My App\",\n    ServerID:   \"server-uuid\",\n    Repository: \"https://github.com/user/repo\",\n})\n</code></pre>"},{"location":"api-services/overview/#servers","title":"Servers","text":"<pre><code>// List servers\nservers, _, _ := client.Servers.List(ctx)\n\n// Get server details\nserver, _, _ := client.Servers.Get(ctx, \"server-uuid\")\n\n// Create server\nnewServer, _, _ := client.Servers.Create(ctx, &amp;pipeops.CreateServerRequest{\n    Name:     \"Production Server\",\n    Provider: \"aws\",\n    Region:   \"us-east-1\",\n})\n</code></pre>"},{"location":"api-services/overview/#teams","title":"Teams","text":"<pre><code>// List teams\nteams, _, _ := client.Teams.List(ctx)\n\n// Create team\nteam, _, _ := client.Teams.Create(ctx, &amp;pipeops.CreateTeamRequest{\n    Name:        \"Development Team\",\n    Description: \"Core developers\",\n})\n\n// Invite member\n_, _ := client.Teams.InviteMember(ctx, teamUUID, &amp;pipeops.InviteTeamMemberRequest{\n    Email: \"member@example.com\",\n    Role:  \"developer\",\n})\n</code></pre>"},{"location":"api-services/overview/#billing","title":"Billing","text":"<pre><code>// Get current balance\nbalance, _, _ := client.Billing.GetBalance(ctx)\n\n// List invoices\ninvoices, _, _ := client.Billing.ListInvoices(ctx, nil)\n\n// Add payment method\ncard, _, _ := client.Billing.AddCard(ctx, &amp;pipeops.AddCardRequest{\n    Token: \"stripe-card-token\",\n})\n</code></pre>"},{"location":"api-services/overview/#webhooks","title":"Webhooks","text":"<pre><code>// Create webhook\nwebhook, _, _ := client.Webhooks.Create(ctx, &amp;pipeops.CreateWebhookRequest{\n    URL:    \"https://myapp.com/webhook\",\n    Events: []string{\"project.deployed\", \"project.failed\"},\n})\n\n// List webhooks\nwebhooks, _, _ := client.Webhooks.List(ctx)\n</code></pre>"},{"location":"api-services/overview/#service-method-categories","title":"Service Method Categories","text":"<p>Services typically include methods for:</p>"},{"location":"api-services/overview/#crud-operations","title":"CRUD Operations","text":"<ul> <li>Create - Create new resources</li> <li>Read - Get or list resources</li> <li>Update - Modify existing resources</li> <li>Delete - Remove resources</li> </ul> <p>Example: <pre><code>// Create\nproject, _, _ := client.Projects.Create(ctx, createReq)\n\n// Read (Get)\nproject, _, _ := client.Projects.Get(ctx, projectUUID)\n\n// Read (List)\nprojects, _, _ := client.Projects.List(ctx, nil)\n\n// Update\nproject, _, _ := client.Projects.Update(ctx, projectUUID, updateReq)\n\n// Delete\n_, _ := client.Projects.Delete(ctx, projectUUID)\n</code></pre></p>"},{"location":"api-services/overview/#actions","title":"Actions","text":"<p>Special operations on resources:</p> <pre><code>// Deploy project\n_, _ := client.Projects.Deploy(ctx, projectUUID)\n\n// Restart project\n_, _ := client.Projects.Restart(ctx, projectUUID)\n\n// Sync deployment\n_, _ := client.Projects.Sync(ctx, projectUUID)\n</code></pre>"},{"location":"api-services/overview/#nested-resources","title":"Nested Resources","text":"<p>Access related resources:</p> <pre><code>// Get project logs\nlogs, _, _ := client.Projects.GetLogs(ctx, projectUUID, nil)\n\n// Get project environment variables\nenvVars, _, _ := client.Projects.GetEnvVars(ctx, projectUUID)\n\n// List project deployments\ndeployments, _, _ := client.Projects.ListDeployments(ctx, projectUUID, nil)\n</code></pre>"},{"location":"api-services/overview/#pagination","title":"Pagination","text":"<p>Many list methods support pagination:</p> <pre><code>// Page 1, 20 items\nprojects, _, _ := client.Projects.List(ctx, &amp;pipeops.ProjectListOptions{\n    Page:  1,\n    Limit: 20,\n})\n\n// Page 2\nprojects, _, _ := client.Projects.List(ctx, &amp;pipeops.ProjectListOptions{\n    Page:  2,\n    Limit: 20,\n})\n</code></pre>"},{"location":"api-services/overview/#filtering","title":"Filtering","text":"<p>Filter resources with options:</p> <pre><code>// Filter projects by workspace\nprojects, _, _ := client.Projects.List(ctx, &amp;pipeops.ProjectListOptions{\n    WorkspaceID: \"workspace-uuid\",\n})\n\n// Filter by server\nprojects, _, _ := client.Projects.List(ctx, &amp;pipeops.ProjectListOptions{\n    ServerID: \"server-uuid\",\n})\n</code></pre>"},{"location":"api-services/overview/#best-practices","title":"Best Practices","text":""},{"location":"api-services/overview/#1-use-context-timeouts","title":"1. Use Context Timeouts","text":"<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\nprojects, _, err := client.Projects.List(ctx, nil)\n</code></pre>"},{"location":"api-services/overview/#2-check-errors","title":"2. Check Errors","text":"<pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif err != nil {\n    log.Printf(\"API error: %v\", err)\n    if resp != nil {\n        log.Printf(\"Status: %d\", resp.StatusCode)\n    }\n    return err\n}\n</code></pre>"},{"location":"api-services/overview/#3-handle-rate-limits","title":"3. Handle Rate Limits","text":"<pre><code>projects, _, err := client.Projects.List(ctx, nil)\nif rateLimitErr, ok := err.(*pipeops.RateLimitError); ok {\n    time.Sleep(rateLimitErr.RetryAfter)\n    // Retry request\n}\n</code></pre>"},{"location":"api-services/overview/#4-reuse-client","title":"4. Reuse Client","text":"<pre><code>// \u2705 Good - Create once, reuse\nclient, _ := pipeops.NewClient(\"\")\nclient.SetToken(token)\n\n// Use for multiple requests\nprojects, _, _ := client.Projects.List(ctx, nil)\nservers, _, _ := client.Servers.List(ctx)\n\n// \u274c Bad - Creating new client for each request\nclient1, _ := pipeops.NewClient(\"\")\nprojects, _, _ := client1.Projects.List(ctx, nil)\n\nclient2, _ := pipeops.NewClient(\"\")\nservers, _, _ := client2.Servers.List(ctx)\n</code></pre>"},{"location":"api-services/overview/#next-steps","title":"Next Steps","text":"<p>Explore detailed documentation for each service:</p> <ul> <li>Projects Service - Comprehensive project management</li> <li>Servers Service - Server and cluster management</li> <li>Teams Service - Team collaboration</li> <li>Billing Service - Payment and subscription management</li> </ul> <p>Or learn about advanced features:</p> <ul> <li>Error Handling</li> <li>Rate Limiting</li> <li>Logging</li> </ul>"},{"location":"api-services/projects/","title":"Projects Service","text":"<p>The Projects Service manages application projects, deployments, and related operations.</p>"},{"location":"api-services/projects/#overview","title":"Overview","text":"<pre><code>// Access the projects service\nprojectsService := client.Projects\n</code></pre>"},{"location":"api-services/projects/#methods","title":"Methods","text":""},{"location":"api-services/projects/#list-projects","title":"List Projects","text":"<p>List all projects with optional filtering:</p> <pre><code>// List all projects\nprojects, _, err := client.Projects.List(ctx, nil)\nif err != nil {\n    log.Fatalf(\"Failed to list projects: %v\", err)\n}\n\nfmt.Printf(\"Found %d projects\\n\", len(projects.Data.Projects))\nfor _, project := range projects.Data.Projects {\n    fmt.Printf(\"- %s (%s)\\n\", project.Name, project.UUID)\n}\n</code></pre> <p>With filters:</p> <pre><code>projects, _, err := client.Projects.List(ctx, &amp;pipeops.ProjectListOptions{\n    WorkspaceID: \"workspace-uuid\",\n    ServerID:    \"server-uuid\",\n    Page:        1,\n    Limit:       20,\n})\n</code></pre>"},{"location":"api-services/projects/#get-project","title":"Get Project","text":"<p>Get a specific project by UUID:</p> <pre><code>project, _, err := client.Projects.Get(ctx, \"project-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get project: %v\", err)\n}\n\nfmt.Printf(\"Project: %s\\n\", project.Data.Project.Name)\nfmt.Printf(\"Status: %s\\n\", project.Data.Project.Status)\nfmt.Printf(\"Repository: %s\\n\", project.Data.Project.Repository)\n</code></pre>"},{"location":"api-services/projects/#create-project","title":"Create Project","text":"<p>Create a new project:</p> <pre><code>newProject, _, err := client.Projects.Create(ctx, &amp;pipeops.CreateProjectRequest{\n    Name:          \"My Application\",\n    Description:   \"Production application\",\n    ServerID:      \"server-uuid\",\n    EnvironmentID: \"environment-uuid\",\n    Repository:    \"https://github.com/user/repo\",\n    Branch:        \"main\",\n    BuildCommand:  \"npm run build\",\n    StartCommand:  \"npm start\",\n    Port:          3000,\n    Framework:     \"nodejs\",\n    EnvVars: map[string]interface{}{\n        \"NODE_ENV\": \"production\",\n        \"API_KEY\":  \"secret-key\",\n    },\n})\nif err != nil {\n    log.Fatalf(\"Failed to create project: %v\", err)\n}\n\nfmt.Printf(\"Created project: %s\\n\", newProject.Data.Project.UUID)\n</code></pre>"},{"location":"api-services/projects/#update-project","title":"Update Project","text":"<p>Update an existing project:</p> <pre><code>updated, _, err := client.Projects.Update(ctx, projectUUID, &amp;pipeops.UpdateProjectRequest{\n    Name:         \"Updated Name\",\n    Description:  \"Updated description\",\n    BuildCommand: \"yarn build\",\n    StartCommand: \"yarn start\",\n    Port:         8080,\n})\nif err != nil {\n    log.Fatalf(\"Failed to update project: %v\", err)\n}\n\nfmt.Println(\"Project updated successfully\")\n</code></pre>"},{"location":"api-services/projects/#delete-project","title":"Delete Project","text":"<p>Delete a project:</p> <pre><code>_, err := client.Projects.Delete(ctx, \"project-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to delete project: %v\", err)\n}\n\nfmt.Println(\"Project deleted successfully\")\n</code></pre>"},{"location":"api-services/projects/#deploy-project","title":"Deploy Project","text":"<p>Trigger a deployment:</p> <pre><code>deployment, _, err := client.Projects.Deploy(ctx, \"project-uuid\")\nif err != nil {\n    log.Fatalf(\"Deployment failed: %v\", err)\n}\n\nfmt.Printf(\"Deployment started: %s\\n\", deployment.Data.DeploymentID)\n</code></pre>"},{"location":"api-services/projects/#get-project-logs","title":"Get Project Logs","text":"<p>Retrieve project logs:</p> <pre><code>logs, _, err := client.Projects.GetLogs(ctx, projectUUID, &amp;pipeops.LogsOptions{\n    Limit:  100,\n    Search: \"error\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to get logs: %v\", err)\n}\n\nfor _, logEntry := range logs.Data.Logs {\n    fmt.Printf(\"Log: %v\\n\", logEntry)\n}\n</code></pre>"},{"location":"api-services/projects/#get-environment-variables","title":"Get Environment Variables","text":"<p>Get project environment variables:</p> <pre><code>envVars, _, err := client.Projects.GetEnvVars(ctx, \"project-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get env vars: %v\", err)\n}\n\nfor key, value := range envVars.Data.EnvVars {\n    fmt.Printf(\"%s=%s\\n\", key, value)\n}\n</code></pre>"},{"location":"api-services/projects/#update-environment-variables","title":"Update Environment Variables","text":"<p>Update project environment variables:</p> <pre><code>_, err := client.Projects.UpdateEnvVars(ctx, projectUUID, &amp;pipeops.UpdateEnvVarsRequest{\n    EnvVars: map[string]string{\n        \"DATABASE_URL\": \"postgresql://...\",\n        \"REDIS_URL\":    \"redis://...\",\n    },\n})\nif err != nil {\n    log.Fatalf(\"Failed to update env vars: %v\", err)\n}\n\nfmt.Println(\"Environment variables updated\")\n</code></pre>"},{"location":"api-services/projects/#restart-project","title":"Restart Project","text":"<p>Restart a project:</p> <pre><code>_, err := client.Projects.Restart(ctx, \"project-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to restart: %v\", err)\n}\n\nfmt.Println(\"Project restarted\")\n</code></pre>"},{"location":"api-services/projects/#get-github-branches","title":"Get GitHub Branches","text":"<p>Get available branches from a GitHub repository:</p> <pre><code>branches, _, err := client.Projects.GetGitHubBranches(ctx, &amp;pipeops.GitHubBranchesRequest{\n    Repository: \"https://github.com/user/repo\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to get branches: %v\", err)\n}\n\nfor _, branch := range branches.Data.Branches {\n    fmt.Printf(\"Branch: %s\\n\", branch)\n}\n</code></pre>"},{"location":"api-services/projects/#update-domain","title":"Update Domain","text":"<p>Update project domain:</p> <pre><code>domain, _, err := client.Projects.UpdateDomain(ctx, projectUUID, &amp;pipeops.DomainRequest{\n    Domain: \"myapp.com\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to update domain: %v\", err)\n}\n\nfmt.Printf(\"Domain updated: %s\\n\", domain.Data.Domain)\n</code></pre>"},{"location":"api-services/projects/#data-types","title":"Data Types","text":""},{"location":"api-services/projects/#project","title":"Project","text":"<pre><code>type Project struct {\n    ID            string     `json:\"id,omitempty\"`\n    UUID          string     `json:\"uuid,omitempty\"`\n    Name          string     `json:\"name,omitempty\"`\n    Description   string     `json:\"description,omitempty\"`\n    Status        string     `json:\"status,omitempty\"`\n    ServerID      string     `json:\"server_id,omitempty\"`\n    EnvironmentID string     `json:\"environment_id,omitempty\"`\n    WorkspaceID   string     `json:\"workspace_id,omitempty\"`\n    Repository    string     `json:\"repository,omitempty\"`\n    Branch        string     `json:\"branch,omitempty\"`\n    BuildCommand  string     `json:\"build_command,omitempty\"`\n    StartCommand  string     `json:\"start_command,omitempty\"`\n    Port          int        `json:\"port,omitempty\"`\n    Framework     string     `json:\"framework,omitempty\"`\n    CreatedAt     *Timestamp `json:\"created_at,omitempty\"`\n    UpdatedAt     *Timestamp `json:\"updated_at,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/projects/#projectlistoptions","title":"ProjectListOptions","text":"<pre><code>type ProjectListOptions struct {\n    WorkspaceID string `url:\"workspace_id,omitempty\"`\n    ServerID    string `url:\"server_id,omitempty\"`\n    Page        int    `url:\"page,omitempty\"`\n    Limit       int    `url:\"limit,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/projects/#complete-example","title":"Complete Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n\n    // Authenticate\n    loginResp, _, _ := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    \"user@example.com\",\n        Password: \"password\",\n    })\n    client.SetToken(loginResp.Data.Token)\n\n    ctx := context.Background()\n\n    // Create a new project\n    project, _, err := client.Projects.Create(ctx, &amp;pipeops.CreateProjectRequest{\n        Name:          \"My Web App\",\n        ServerID:      \"server-uuid\",\n        EnvironmentID: \"env-uuid\",\n        Repository:    \"https://github.com/user/webapp\",\n        Branch:        \"main\",\n        BuildCommand:  \"npm run build\",\n        StartCommand:  \"npm start\",\n        Port:          3000,\n    })\n    if err != nil {\n        log.Fatalf(\"Failed to create project: %v\", err)\n    }\n\n    projectUUID := project.Data.Project.UUID\n    fmt.Printf(\"Created project: %s\\n\", projectUUID)\n\n    // Deploy the project\n    deployment, _, err := client.Projects.Deploy(ctx, projectUUID)\n    if err != nil {\n        log.Fatalf(\"Deployment failed: %v\", err)\n    }\n\n    fmt.Printf(\"Deployment started: %s\\n\", deployment.Data.DeploymentID)\n\n    // Get logs\n    logs, _, err := client.Projects.GetLogs(ctx, projectUUID, nil)\n    if err != nil {\n        log.Fatalf(\"Failed to get logs: %v\", err)\n    }\n\n    fmt.Printf(\"Retrieved %d log entries\\n\", len(logs.Data.Logs))\n}\n</code></pre>"},{"location":"api-services/projects/#see-also","title":"See Also","text":"<ul> <li>Servers Service - Manage servers for projects</li> <li>Environments Service - Configure project environments</li> <li>Webhooks Service - Set up deployment webhooks</li> </ul>"},{"location":"api-services/servers/","title":"Servers Service","text":"<p>The Servers Service manages server clusters, agents, and service tokens for infrastructure management.</p>"},{"location":"api-services/servers/#overview","title":"Overview","text":"<pre><code>// Access the servers service\nserversService := client.Servers\n</code></pre>"},{"location":"api-services/servers/#methods","title":"Methods","text":""},{"location":"api-services/servers/#list-servers","title":"List Servers","text":"<p>List all servers:</p> <pre><code>servers, _, err := client.Servers.List(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list servers: %v\", err)\n}\n\nfmt.Printf(\"Found %d servers\\n\", len(servers.Data.Servers))\nfor _, server := range servers.Data.Servers {\n    fmt.Printf(\"- %s (%s) - Provider: %s\\n\", server.Name, server.UUID, server.Provider)\n}\n</code></pre>"},{"location":"api-services/servers/#get-server","title":"Get Server","text":"<p>Get a specific server by UUID:</p> <pre><code>server, _, err := client.Servers.Get(ctx, \"server-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get server: %v\", err)\n}\n\nfmt.Printf(\"Server: %s\\n\", server.Data.Server.Name)\nfmt.Printf(\"Provider: %s\\n\", server.Data.Server.Provider)\nfmt.Printf(\"Region: %s\\n\", server.Data.Server.Region)\nfmt.Printf(\"Status: %s\\n\", server.Data.Server.Status)\n</code></pre>"},{"location":"api-services/servers/#create-server","title":"Create Server","text":"<p>Create a new server cluster:</p> <pre><code>newServer, _, err := client.Servers.Create(ctx, &amp;pipeops.CreateServerRequest{\n    Name:     \"Production Cluster\",\n    Provider: \"aws\",\n    Region:   \"us-east-1\",\n    Size:     \"t3.medium\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to create server: %v\", err)\n}\n\nfmt.Printf(\"Created server: %s\\n\", newServer.Data.Server.UUID)\n</code></pre>"},{"location":"api-services/servers/#delete-server","title":"Delete Server","text":"<p>Delete a server:</p> <pre><code>_, err := client.Servers.Delete(ctx, \"server-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to delete server: %v\", err)\n}\n\nfmt.Println(\"Server deleted successfully\")\n</code></pre>"},{"location":"api-services/servers/#register-agent","title":"Register Agent","text":"<p>Register a PipeOps agent on a cluster:</p> <pre><code>agent, _, err := client.Servers.RegisterAgent(ctx, &amp;pipeops.AgentRegisterRequest{\n    ClusterUUID: \"cluster-uuid\",\n    AgentToken:  \"agent-token\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to register agent: %v\", err)\n}\n\nfmt.Printf(\"Agent registered: %s\\n\", agent.Data.AgentID)\n</code></pre>"},{"location":"api-services/servers/#agent-heartbeat","title":"Agent Heartbeat","text":"<p>Send agent heartbeat to maintain connection:</p> <pre><code>_, err := client.Servers.AgentHeartbeat(ctx, clusterUUID, &amp;pipeops.AgentHeartbeatRequest{\n    Status:  \"healthy\",\n    Metrics: map[string]interface{}{\n        \"cpu\":    45.2,\n        \"memory\": 62.8,\n    },\n})\nif err != nil {\n    log.Fatalf(\"Heartbeat failed: %v\", err)\n}\n</code></pre>"},{"location":"api-services/servers/#get-agent-config","title":"Get Agent Config","text":"<p>Get agent configuration:</p> <pre><code>config, _, err := client.Servers.GetAgentConfig(ctx, \"cluster-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get config: %v\", err)\n}\n\nfmt.Printf(\"Agent config: %+v\\n\", config.Data)\n</code></pre>"},{"location":"api-services/servers/#get-cluster-connection","title":"Get Cluster Connection","text":"<p>Get cluster connection details:</p> <pre><code>connection, _, err := client.Servers.GetClusterConnection(ctx, \"cluster-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get connection: %v\", err)\n}\n\nfmt.Printf(\"Endpoint: %s\\n\", connection.Data.Endpoint)\n</code></pre>"},{"location":"api-services/servers/#create-service-token","title":"Create Service Token","text":"<p>Create a service account token:</p> <pre><code>token, _, err := client.Servers.CreateServiceToken(ctx, &amp;pipeops.ServiceTokenRequest{\n    Name:        \"CI/CD Token\",\n    Description: \"For automated deployments\",\n    Scopes:      []string{\"projects:write\", \"deployments:create\"},\n})\nif err != nil {\n    log.Fatalf(\"Failed to create token: %v\", err)\n}\n\nfmt.Printf(\"Service token: %s\\n\", token.Data.Token)\n</code></pre>"},{"location":"api-services/servers/#list-service-tokens","title":"List Service Tokens","text":"<p>List all service tokens:</p> <pre><code>tokens, _, err := client.Servers.ListServiceTokens(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list tokens: %v\", err)\n}\n\nfor _, token := range tokens.Data.Tokens {\n    fmt.Printf(\"- %s (%s)\\n\", token.Name, token.UUID)\n}\n</code></pre>"},{"location":"api-services/servers/#revoke-service-token","title":"Revoke Service Token","text":"<p>Revoke a service token:</p> <pre><code>_, err := client.Servers.RevokeServiceToken(ctx, \"token-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to revoke token: %v\", err)\n}\n\nfmt.Println(\"Token revoked\")\n</code></pre>"},{"location":"api-services/servers/#data-types","title":"Data Types","text":""},{"location":"api-services/servers/#server","title":"Server","text":"<pre><code>type Server struct {\n    ID       string     `json:\"id,omitempty\"`\n    UUID     string     `json:\"uuid,omitempty\"`\n    Name     string     `json:\"name,omitempty\"`\n    Provider string     `json:\"provider,omitempty\"`\n    Region   string     `json:\"region,omitempty\"`\n    Size     string     `json:\"size,omitempty\"`\n    Status   string     `json:\"status,omitempty\"`\n    CreatedAt *Timestamp `json:\"created_at,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/servers/#complete-example","title":"Complete Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n    client.SetToken(\"your-token\")\n\n    ctx := context.Background()\n\n    // List all servers\n    servers, _, err := client.Servers.List(ctx)\n    if err != nil {\n        log.Fatalf(\"Failed to list servers: %v\", err)\n    }\n\n    fmt.Printf(\"Found %d servers:\\n\", len(servers.Data.Servers))\n    for _, server := range servers.Data.Servers {\n        fmt.Printf(\"- %s: %s on %s\\n\", server.Name, server.Provider, server.Region)\n    }\n\n    // Get details of first server\n    if len(servers.Data.Servers) &gt; 0 {\n        serverUUID := servers.Data.Servers[0].UUID\n        server, _, err := client.Servers.Get(ctx, serverUUID)\n        if err != nil {\n            log.Fatalf(\"Failed to get server: %v\", err)\n        }\n\n        fmt.Printf(\"\\nServer Details:\\n\")\n        fmt.Printf(\"Name: %s\\n\", server.Data.Server.Name)\n        fmt.Printf(\"Status: %s\\n\", server.Data.Server.Status)\n    }\n}\n</code></pre>"},{"location":"api-services/servers/#see-also","title":"See Also","text":"<ul> <li>Projects Service - Deploy projects to servers</li> <li>Cloud Providers Service - Manage cloud provider connections</li> <li>Service Tokens Service - Service account management</li> </ul>"},{"location":"api-services/servicetokens/","title":"Service Tokens Service","text":"<p>The Service Tokens Service manages service account tokens for API access.</p>"},{"location":"api-services/servicetokens/#overview","title":"Overview","text":"<pre><code>// Access the service tokens service\nserviceTokensService := client.ServiceTokens\n</code></pre>"},{"location":"api-services/servicetokens/#methods","title":"Methods","text":""},{"location":"api-services/servicetokens/#create-service-account-token","title":"Create Service Account Token","text":"<p>Create a new service account token:</p> <pre><code>token, _, err := client.ServiceTokens.CreateServiceAccountToken(ctx, &amp;pipeops.ServiceAccountTokenRequest{\n    Name:        \"CI/CD Token\",\n    Description: \"For automated deployments\",\n    Scopes:      []string{\"projects:write\", \"deployments:create\"},\n    ExpiresIn:   \"30d\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to create token: %v\", err)\n}\n\nfmt.Printf(\"Token: %s\\n\", token.Data.Token)\nfmt.Printf(\"Token ID: %s\\n\", token.Data.UUID)\n</code></pre>"},{"location":"api-services/servicetokens/#list-service-account-tokens","title":"List Service Account Tokens","text":"<p>List all service account tokens:</p> <pre><code>tokens, _, err := client.ServiceTokens.ListServiceAccountTokens(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list tokens: %v\", err)\n}\n\nfor _, token := range tokens.Data.Tokens {\n    fmt.Printf(\"- %s (%s)\\n\", token.Name, token.UUID)\n}\n</code></pre>"},{"location":"api-services/servicetokens/#get-service-account-token","title":"Get Service Account Token","text":"<p>Get token details:</p> <pre><code>token, _, err := client.ServiceTokens.GetServiceAccountToken(ctx, \"token-uuid\")\n</code></pre>"},{"location":"api-services/servicetokens/#update-service-account-token","title":"Update Service Account Token","text":"<p>Update token metadata:</p> <pre><code>updated, _, err := client.ServiceTokens.UpdateServiceAccountToken(ctx, tokenUUID, &amp;pipeops.ServiceAccountTokenUpdateRequest{\n    Name:        \"Updated Name\",\n    Description: \"Updated description\",\n})\n</code></pre>"},{"location":"api-services/servicetokens/#revoke-service-account-token","title":"Revoke Service Account Token","text":"<p>Revoke a token:</p> <pre><code>_, err := client.ServiceTokens.RevokeServiceAccountToken(ctx, \"token-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to revoke token: %v\", err)\n}\n\nfmt.Println(\"Token revoked successfully\")\n</code></pre>"},{"location":"api-services/servicetokens/#complete-example","title":"Complete Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n    client.SetToken(\"your-admin-token\")\n\n    ctx := context.Background()\n\n    // Create service token for CI/CD\n    token, _, err := client.ServiceTokens.CreateServiceAccountToken(ctx, &amp;pipeops.ServiceAccountTokenRequest{\n        Name:        \"GitHub Actions\",\n        Description: \"Token for GitHub Actions CI/CD\",\n        Scopes:      []string{\"projects:write\", \"deployments:create\"},\n    })\n    if err != nil {\n        log.Fatalf(\"Failed to create token: %v\", err)\n    }\n\n    fmt.Printf(\"Created token: %s\\n\", token.Data.UUID)\n    fmt.Printf(\"Save this token securely: %s\\n\", token.Data.Token)\n\n    // List all tokens\n    tokens, _, err := client.ServiceTokens.ListServiceAccountTokens(ctx)\n    if err != nil {\n        log.Fatalf(\"Failed to list tokens: %v\", err)\n    }\n\n    fmt.Printf(\"\\nActive tokens:\\n\")\n    for _, t := range tokens.Data.Tokens {\n        fmt.Printf(\"- %s: %s\\n\", t.Name, t.CreatedAt)\n    }\n}\n</code></pre>"},{"location":"api-services/servicetokens/#best-practices","title":"Best Practices","text":"<ol> <li>Scope Tokens: Only grant necessary permissions</li> <li>Rotate Regularly: Create new tokens periodically</li> <li>Store Securely: Keep tokens in secure storage</li> <li>Monitor Usage: Track token usage and revoke unused tokens</li> </ol>"},{"location":"api-services/servicetokens/#see-also","title":"See Also","text":"<ul> <li>Authentication Overview</li> <li>Servers Service</li> </ul>"},{"location":"api-services/teams/","title":"Teams Service","text":"<p>The Teams Service manages team collaboration and member management.</p>"},{"location":"api-services/teams/#overview","title":"Overview","text":"<pre><code>// Access the teams service\nteamsService := client.Teams\n</code></pre>"},{"location":"api-services/teams/#methods","title":"Methods","text":""},{"location":"api-services/teams/#list-teams","title":"List Teams","text":"<p>List all teams:</p> <pre><code>teams, _, err := client.Teams.List(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list teams: %v\", err)\n}\n\nfor _, team := range teams.Data.Teams {\n    fmt.Printf(\"- %s\\n\", team.Name)\n}\n</code></pre>"},{"location":"api-services/teams/#create-team","title":"Create Team","text":"<p>Create a new team:</p> <pre><code>team, _, err := client.Teams.Create(ctx, &amp;pipeops.CreateTeamRequest{\n    Name:        \"Development Team\",\n    Description: \"Core development team\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to create team: %v\", err)\n}\n\nfmt.Printf(\"Created team: %s\\n\", team.Data.Team.UUID)\n</code></pre>"},{"location":"api-services/teams/#get-team","title":"Get Team","text":"<p>Get team details:</p> <pre><code>team, _, err := client.Teams.Get(ctx, \"team-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get team: %v\", err)\n}\n\nfmt.Printf(\"Team: %s\\n\", team.Data.Team.Name)\n</code></pre>"},{"location":"api-services/teams/#update-team","title":"Update Team","text":"<p>Update team information:</p> <pre><code>updated, _, err := client.Teams.Update(ctx, teamUUID, &amp;pipeops.UpdateTeamRequest{\n    Name:        \"Updated Team Name\",\n    Description: \"Updated description\",\n})\n</code></pre>"},{"location":"api-services/teams/#delete-team","title":"Delete Team","text":"<p>Delete a team:</p> <pre><code>_, err := client.Teams.Delete(ctx, \"team-uuid\")\n</code></pre>"},{"location":"api-services/teams/#invite-member","title":"Invite Member","text":"<p>Invite a member to the team:</p> <pre><code>_, err := client.Teams.InviteMember(ctx, teamUUID, &amp;pipeops.InviteTeamMemberRequest{\n    Email: \"member@example.com\",\n    Role:  \"developer\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to invite member: %v\", err)\n}\n\nfmt.Println(\"Invitation sent\")\n</code></pre>"},{"location":"api-services/teams/#list-members","title":"List Members","text":"<p>List team members:</p> <pre><code>members, _, err := client.Teams.ListMembers(ctx, \"team-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to list members: %v\", err)\n}\n\nfor _, member := range members.Data.Members {\n    fmt.Printf(\"- %s (%s)\\n\", member.Email, member.Role)\n}\n</code></pre>"},{"location":"api-services/teams/#remove-member","title":"Remove Member","text":"<p>Remove a member from team:</p> <pre><code>_, err := client.Teams.RemoveMember(ctx, teamUUID, memberUUID)\n</code></pre>"},{"location":"api-services/teams/#update-member-role","title":"Update Member Role","text":"<p>Update a member's role:</p> <pre><code>_, err := client.Teams.UpdateMemberRole(ctx, teamUUID, memberUUID, &amp;pipeops.UpdateMemberRoleRequest{\n    Role: \"admin\",\n})\n</code></pre>"},{"location":"api-services/teams/#accept-invitation","title":"Accept Invitation","text":"<p>Accept a team invitation:</p> <pre><code>_, err := client.Teams.AcceptInvitation(ctx, \"invite-token\")\n</code></pre>"},{"location":"api-services/teams/#reject-invitation","title":"Reject Invitation","text":"<p>Reject a team invitation:</p> <pre><code>_, err := client.Teams.RejectInvitation(ctx, \"invite-token\")\n</code></pre>"},{"location":"api-services/teams/#data-types","title":"Data Types","text":"<pre><code>type Team struct {\n    ID          string `json:\"id,omitempty\"`\n    UUID        string `json:\"uuid,omitempty\"`\n    Name        string `json:\"name,omitempty\"`\n    Description string `json:\"description,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/teams/#see-also","title":"See Also","text":"<ul> <li>Workspaces Service</li> <li>Users Service</li> </ul>"},{"location":"api-services/users/","title":"Users Service","text":"<p>The Users Service manages user profile and settings.</p>"},{"location":"api-services/users/#overview","title":"Overview","text":"<pre><code>// Access the users service\nusersService := client.Users\n</code></pre>"},{"location":"api-services/users/#methods","title":"Methods","text":""},{"location":"api-services/users/#get-profile","title":"Get Profile","text":"<p>Get current user profile:</p> <pre><code>profile, _, err := client.Users.GetProfile(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to get profile: %v\", err)\n}\n\nfmt.Printf(\"Name: %s %s\\n\", profile.Data.User.FirstName, profile.Data.User.LastName)\nfmt.Printf(\"Email: %s\\n\", profile.Data.User.Email)\n</code></pre>"},{"location":"api-services/users/#update-profile","title":"Update Profile","text":"<p>Update user profile:</p> <pre><code>updated, _, err := client.Users.UpdateProfile(ctx, &amp;pipeops.UpdateProfileRequest{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Phone:     \"+1234567890\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to update profile: %v\", err)\n}\n\nfmt.Println(\"Profile updated successfully\")\n</code></pre>"},{"location":"api-services/users/#get-settings","title":"Get Settings","text":"<p>Get user settings:</p> <pre><code>settings, _, err := client.Users.GetSettings(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to get settings: %v\", err)\n}\n\nfmt.Printf(\"Theme: %s\\n\", settings.Data.Settings.Theme)\n</code></pre>"},{"location":"api-services/users/#update-settings","title":"Update Settings","text":"<p>Update user settings:</p> <pre><code>_, err := client.Users.UpdateSettings(ctx, &amp;pipeops.UpdateSettingsRequest{\n    Theme:       \"dark\",\n    Language:    \"en\",\n    Timezone:    \"UTC\",\n})\n</code></pre>"},{"location":"api-services/users/#update-notification-settings","title":"Update Notification Settings","text":"<p>Update notification preferences:</p> <pre><code>_, err := client.Users.UpdateNotificationSettings(ctx, &amp;pipeops.UpdateNotificationSettingsRequest{\n    EmailNotifications: true,\n    DeploymentAlerts:   true,\n    SecurityAlerts:     true,\n})\n</code></pre>"},{"location":"api-services/users/#reset-secret-token","title":"Reset Secret Token","text":"<p>Reset user's secret token:</p> <pre><code>token, _, err := client.Users.ResetSecretToken(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to reset token: %v\", err)\n}\n\nfmt.Printf(\"New token: %s\\n\", token.Data.Token)\n</code></pre>"},{"location":"api-services/users/#delete-profile","title":"Delete Profile","text":"<p>Request profile deletion:</p> <pre><code>_, err := client.Users.DeleteProfile(ctx)\n</code></pre>"},{"location":"api-services/users/#cancel-profile-deletion","title":"Cancel Profile Deletion","text":"<p>Cancel a pending profile deletion:</p> <pre><code>_, err := client.Users.CancelProfileDeletion(ctx)\n</code></pre>"},{"location":"api-services/users/#complete-example","title":"Complete Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n    client.SetToken(\"your-token\")\n\n    ctx := context.Background()\n\n    // Get current profile\n    profile, _, err := client.Users.GetProfile(ctx)\n    if err != nil {\n        log.Fatalf(\"Failed to get profile: %v\", err)\n    }\n\n    fmt.Printf(\"Current Profile:\\n\")\n    fmt.Printf(\"Name: %s %s\\n\", \n        profile.Data.User.FirstName, \n        profile.Data.User.LastName)\n    fmt.Printf(\"Email: %s\\n\", profile.Data.User.Email)\n\n    // Update profile\n    _, err = client.Users.UpdateProfile(ctx, &amp;pipeops.UpdateProfileRequest{\n        FirstName: \"Updated\",\n        LastName:  \"Name\",\n    })\n    if err != nil {\n        log.Fatalf(\"Failed to update: %v\", err)\n    }\n\n    fmt.Println(\"\\nProfile updated successfully\")\n}\n</code></pre>"},{"location":"api-services/users/#see-also","title":"See Also","text":"<ul> <li>Auth Service</li> <li>Teams Service</li> </ul>"},{"location":"api-services/webhooks/","title":"Webhooks Service","text":"<p>The Webhooks Service manages webhook configuration and delivery.</p>"},{"location":"api-services/webhooks/#overview","title":"Overview","text":"<pre><code>// Access the webhooks service\nwebhooksService := client.Webhooks\n</code></pre>"},{"location":"api-services/webhooks/#methods","title":"Methods","text":""},{"location":"api-services/webhooks/#list-webhooks","title":"List Webhooks","text":"<p>List all webhooks:</p> <pre><code>webhooks, _, err := client.Webhooks.List(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list webhooks: %v\", err)\n}\n\nfor _, webhook := range webhooks.Data.Webhooks {\n    fmt.Printf(\"- %s: %s\\n\", webhook.Name, webhook.URL)\n}\n</code></pre>"},{"location":"api-services/webhooks/#create-webhook","title":"Create Webhook","text":"<p>Create a new webhook:</p> <pre><code>webhook, _, err := client.Webhooks.Create(ctx, &amp;pipeops.CreateWebhookRequest{\n    URL:    \"https://myapp.com/webhook\",\n    Events: []string{\"project.deployed\", \"project.failed\", \"project.started\"},\n    Secret: \"webhook-secret\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to create webhook: %v\", err)\n}\n\nfmt.Printf(\"Created webhook: %s\\n\", webhook.Data.Webhook.UUID)\n</code></pre>"},{"location":"api-services/webhooks/#get-webhook","title":"Get Webhook","text":"<p>Get webhook details:</p> <pre><code>webhook, _, err := client.Webhooks.Get(ctx, \"webhook-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get webhook: %v\", err)\n}\n\nfmt.Printf(\"Webhook: %s\\n\", webhook.Data.Webhook.URL)\n</code></pre>"},{"location":"api-services/webhooks/#update-webhook","title":"Update Webhook","text":"<p>Update webhook configuration:</p> <pre><code>updated, _, err := client.Webhooks.Update(ctx, webhookUUID, &amp;pipeops.UpdateWebhookRequest{\n    URL:    \"https://myapp.com/new-webhook\",\n    Events: []string{\"project.deployed\"},\n})\n</code></pre>"},{"location":"api-services/webhooks/#delete-webhook","title":"Delete Webhook","text":"<p>Delete a webhook:</p> <pre><code>_, err := client.Webhooks.Delete(ctx, \"webhook-uuid\")\n</code></pre>"},{"location":"api-services/webhooks/#test-webhook","title":"Test Webhook","text":"<p>Test webhook delivery:</p> <pre><code>_, err := client.Webhooks.TestWebhook(ctx, \"webhook-uuid\")\nif err != nil {\n    log.Fatalf(\"Test failed: %v\", err)\n}\n\nfmt.Println(\"Test webhook sent\")\n</code></pre>"},{"location":"api-services/webhooks/#get-webhook-deliveries","title":"Get Webhook Deliveries","text":"<p>Get webhook delivery history:</p> <pre><code>deliveries, _, err := client.Webhooks.GetWebhookDeliveries(ctx, \"webhook-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get deliveries: %v\", err)\n}\n\nfor _, delivery := range deliveries.Data.Deliveries {\n    fmt.Printf(\"Delivery: %s - Status: %d\\n\", delivery.ID, delivery.StatusCode)\n}\n</code></pre>"},{"location":"api-services/webhooks/#retry-webhook-delivery","title":"Retry Webhook Delivery","text":"<p>Retry a failed webhook delivery:</p> <pre><code>_, err := client.Webhooks.RetryWebhookDelivery(ctx, webhookUUID, deliveryID)\n</code></pre>"},{"location":"api-services/webhooks/#data-types","title":"Data Types","text":"<pre><code>type Webhook struct {\n    ID     string   `json:\"id,omitempty\"`\n    UUID   string   `json:\"uuid,omitempty\"`\n    URL    string   `json:\"url,omitempty\"`\n    Events []string `json:\"events,omitempty\"`\n    Secret string   `json:\"secret,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/webhooks/#available-events","title":"Available Events","text":"<ul> <li><code>project.deployed</code> - Project deployment completed</li> <li><code>project.failed</code> - Project deployment failed</li> <li><code>project.started</code> - Project deployment started</li> <li><code>project.stopped</code> - Project stopped</li> <li><code>project.restarted</code> - Project restarted</li> <li><code>project.deleted</code> - Project deleted</li> </ul>"},{"location":"api-services/webhooks/#see-also","title":"See Also","text":"<ul> <li>Projects Service</li> </ul>"},{"location":"api-services/workspaces/","title":"Workspaces Service","text":"<p>The Workspaces Service manages workspace organization and settings.</p>"},{"location":"api-services/workspaces/#overview","title":"Overview","text":"<pre><code>// Access the workspaces service\nworkspacesService := client.Workspaces\n</code></pre>"},{"location":"api-services/workspaces/#methods","title":"Methods","text":""},{"location":"api-services/workspaces/#list-workspaces","title":"List Workspaces","text":"<p>List all workspaces:</p> <pre><code>workspaces, _, err := client.Workspaces.List(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to list workspaces: %v\", err)\n}\n\nfor _, workspace := range workspaces.Data.Workspaces {\n    fmt.Printf(\"- %s\\n\", workspace.Name)\n}\n</code></pre>"},{"location":"api-services/workspaces/#create-workspace","title":"Create Workspace","text":"<p>Create a new workspace:</p> <pre><code>workspace, _, err := client.Workspaces.Create(ctx, &amp;pipeops.CreateWorkspaceRequest{\n    Name:        \"Production Workspace\",\n    Description: \"Production environment\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to create workspace: %v\", err)\n}\n\nfmt.Printf(\"Created workspace: %s\\n\", workspace.Data.Workspace.UUID)\n</code></pre>"},{"location":"api-services/workspaces/#get-workspace","title":"Get Workspace","text":"<p>Get workspace details:</p> <pre><code>workspace, _, err := client.Workspaces.Get(ctx, \"workspace-uuid\")\nif err != nil {\n    log.Fatalf(\"Failed to get workspace: %v\", err)\n}\n\nfmt.Printf(\"Workspace: %s\\n\", workspace.Data.Workspace.Name)\n</code></pre>"},{"location":"api-services/workspaces/#update-workspace","title":"Update Workspace","text":"<p>Update workspace information:</p> <pre><code>updated, _, err := client.Workspaces.Update(ctx, workspaceUUID, &amp;pipeops.UpdateWorkspaceRequest{\n    Name:        \"Updated Name\",\n    Description: \"Updated description\",\n})\n</code></pre>"},{"location":"api-services/workspaces/#delete-workspace","title":"Delete Workspace","text":"<p>Delete a workspace:</p> <pre><code>_, err := client.Workspaces.Delete(ctx, \"workspace-uuid\")\n</code></pre>"},{"location":"api-services/workspaces/#set-billing-email","title":"Set Billing Email","text":"<p>Set billing email for workspace:</p> <pre><code>_, err := client.Workspaces.SetBillingEmail(ctx, workspaceUUID, &amp;pipeops.SetBillingEmailRequest{\n    Email: \"billing@example.com\",\n})\n</code></pre>"},{"location":"api-services/workspaces/#data-types","title":"Data Types","text":"<pre><code>type Workspace struct {\n    ID          string `json:\"id,omitempty\"`\n    UUID        string `json:\"uuid,omitempty\"`\n    Name        string `json:\"name,omitempty\"`\n    Description string `json:\"description,omitempty\"`\n}\n</code></pre>"},{"location":"api-services/workspaces/#see-also","title":"See Also","text":"<ul> <li>Projects Service</li> <li>Teams Service</li> <li>Billing Service</li> </ul>"},{"location":"authentication/basic-auth/","title":"Basic Authentication","text":"<p>Basic authentication using email and password is the most straightforward way to authenticate with the PipeOps API.</p>"},{"location":"authentication/basic-auth/#login","title":"Login","text":"<p>Authenticate a user and receive an access token:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n    ctx := context.Background()\n\n    // Login with email and password\n    resp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    \"user@example.com\",\n        Password: \"your-password\",\n    })\n    if err != nil {\n        log.Fatalf(\"Login failed: %v\", err)\n    }\n\n    fmt.Printf(\"Login successful!\\n\")\n    fmt.Printf(\"Token: %s\\n\", resp.Data.Token)\n    fmt.Printf(\"User: %s %s\\n\", resp.Data.User.FirstName, resp.Data.User.LastName)\n\n    // Set token for authenticated requests\n    client.SetToken(resp.Data.Token)\n}\n</code></pre>"},{"location":"authentication/basic-auth/#request","title":"Request","text":"<pre><code>type LoginRequest struct {\n    Email    string `json:\"email\"`\n    Password string `json:\"password\"`\n}\n</code></pre>"},{"location":"authentication/basic-auth/#response","title":"Response","text":"<pre><code>type LoginResponse struct {\n    Status  string `json:\"status\"`\n    Message string `json:\"message\"`\n    Data    struct {\n        Token string `json:\"token\"`\n        User  User   `json:\"user\"`\n    } `json:\"data\"`\n}\n</code></pre>"},{"location":"authentication/basic-auth/#signup","title":"Signup","text":"<p>Create a new user account:</p> <pre><code>resp, _, err := client.Auth.Signup(ctx, &amp;pipeops.SignupRequest{\n    Email:     \"newuser@example.com\",\n    Password:  \"secure-password\",\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n})\nif err != nil {\n    log.Fatalf(\"Signup failed: %v\", err)\n}\n\nfmt.Printf(\"Account created for: %s\\n\", resp.Data.User.Email)\n</code></pre>"},{"location":"authentication/basic-auth/#request_1","title":"Request","text":"<pre><code>type SignupRequest struct {\n    Email     string `json:\"email\"`\n    Password  string `json:\"password\"`\n    FirstName string `json:\"first_name,omitempty\"`\n    LastName  string `json:\"last_name,omitempty\"`\n}\n</code></pre> <p>Validation: - Email must be valid format - Password must be at least 6 characters - Email must not already exist</p>"},{"location":"authentication/basic-auth/#change-password","title":"Change Password","text":"<p>Change password for an authenticated user:</p> <pre><code>// Must be authenticated first\nclient.SetToken(userToken)\n\nresp, _, err := client.Auth.ChangePassword(ctx, &amp;pipeops.ChangePasswordRequest{\n    OldPassword: \"current-password\",\n    NewPassword: \"new-secure-password\",\n})\nif err != nil {\n    log.Fatalf(\"Password change failed: %v\", err)\n}\n\nfmt.Println(\"Password changed successfully!\")\n</code></pre>"},{"location":"authentication/basic-auth/#request_2","title":"Request","text":"<pre><code>type ChangePasswordRequest struct {\n    OldPassword string `json:\"old_password\"`\n    NewPassword string `json:\"new_password\"`\n}\n</code></pre>"},{"location":"authentication/basic-auth/#password-reset-flow","title":"Password Reset Flow","text":""},{"location":"authentication/basic-auth/#step-1-request-password-reset","title":"Step 1: Request Password Reset","text":"<p>Send a password reset email:</p> <pre><code>resp, _, err := client.Auth.RequestPasswordReset(ctx, &amp;pipeops.PasswordResetRequest{\n    Email: \"user@example.com\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to request reset: %v\", err)\n}\n\nfmt.Println(\"Password reset email sent!\")\n</code></pre>"},{"location":"authentication/basic-auth/#step-2-verify-reset-token-optional","title":"Step 2: Verify Reset Token (Optional)","text":"<p>Verify the token from the email is valid:</p> <pre><code>token := \"reset-token-from-email\"\n\nresp, err := client.Auth.VerifyPasswordResetToken(ctx, token)\nif err != nil {\n    log.Fatalf(\"Invalid or expired token: %v\", err)\n}\n\nfmt.Println(\"Token is valid!\")\n</code></pre>"},{"location":"authentication/basic-auth/#step-3-reset-password","title":"Step 3: Reset Password","text":"<p>Complete the password reset:</p> <pre><code>resp, err := client.Auth.ResetPassword(ctx, &amp;pipeops.ResetPasswordRequest{\n    Token:       \"reset-token-from-email\",\n    NewPassword: \"new-secure-password\",\n})\nif err != nil {\n    log.Fatalf(\"Password reset failed: %v\", err)\n}\n\nfmt.Println(\"Password reset successful!\")\n</code></pre>"},{"location":"authentication/basic-auth/#email-verification","title":"Email Verification","text":"<p>Activate a user's email address:</p> <pre><code>resp, err := client.Auth.ActivateEmail(ctx, &amp;pipeops.ActivateEmailRequest{\n    Token: \"activation-token-from-email\",\n})\nif err != nil {\n    log.Fatalf(\"Email activation failed: %v\", err)\n}\n\nfmt.Println(\"Email activated successfully!\")\n</code></pre>"},{"location":"authentication/basic-auth/#two-factor-authentication","title":"Two-Factor Authentication","text":"<p>If 2FA is enabled, verify the login with a code:</p> <pre><code>// Initial login returns a pending status if 2FA is enabled\nloginResp, _, _ := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n    Email:    \"user@example.com\",\n    Password: \"password\",\n})\n\n// Verify with 2FA code\nresp, _, err := client.Auth.VerifyLogin(ctx, &amp;pipeops.VerifyLoginRequest{\n    Email: \"user@example.com\",\n    Code:  \"123456\", // Code from authenticator app\n})\nif err != nil {\n    log.Fatalf(\"2FA verification failed: %v\", err)\n}\n\n// Set the token after successful verification\nclient.SetToken(resp.Data.Token)\n</code></pre>"},{"location":"authentication/basic-auth/#complete-authentication-example","title":"Complete Authentication Example","text":"<p>Here's a complete example with error handling:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc authenticate(email, password string) (*pipeops.Client, error) {\n    // Create client with timeout\n    client, err := pipeops.NewClient(\"\",\n        pipeops.WithTimeout(30*time.Second),\n        pipeops.WithMaxRetries(3),\n    )\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create client: %w\", err)\n    }\n\n    // Set request timeout\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    // Validate input\n    if email == \"\" || password == \"\" {\n        return nil, errors.New(\"email and password are required\")\n    }\n\n    // Attempt login\n    resp, httpResp, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    email,\n        Password: password,\n    })\n    if err != nil {\n        // Check for specific errors\n        if httpResp != nil {\n            switch httpResp.StatusCode {\n            case 401:\n                return nil, errors.New(\"invalid email or password\")\n            case 429:\n                return nil, errors.New(\"too many login attempts, please try again later\")\n            case 500:\n                return nil, errors.New(\"server error, please try again\")\n            }\n        }\n        return nil, fmt.Errorf(\"login failed: %w\", err)\n    }\n\n    // Set token\n    client.SetToken(resp.Data.Token)\n\n    log.Printf(\"Authenticated as: %s\\n\", resp.Data.User.Email)\n\n    return client, nil\n}\n\nfunc main() {\n    email := \"user@example.com\"\n    password := \"your-password\"\n\n    client, err := authenticate(email, password)\n    if err != nil {\n        log.Fatalf(\"Authentication failed: %v\", err)\n    }\n\n    // Use authenticated client\n    ctx := context.Background()\n    projects, _, err := client.Projects.List(ctx, nil)\n    if err != nil {\n        log.Fatalf(\"Failed to list projects: %v\", err)\n    }\n\n    fmt.Printf(\"Found %d projects\\n\", len(projects.Data.Projects))\n}\n</code></pre>"},{"location":"authentication/basic-auth/#best-practices","title":"Best Practices","text":""},{"location":"authentication/basic-auth/#1-use-environment-variables","title":"1. Use Environment Variables","text":"<pre><code>import \"os\"\n\nemail := os.Getenv(\"PIPEOPS_EMAIL\")\npassword := os.Getenv(\"PIPEOPS_PASSWORD\")\n\nif email == \"\" || password == \"\" {\n    log.Fatal(\"Set PIPEOPS_EMAIL and PIPEOPS_PASSWORD environment variables\")\n}\n</code></pre>"},{"location":"authentication/basic-auth/#2-implement-timeout","title":"2. Implement Timeout","text":"<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\n\nresp, _, err := client.Auth.Login(ctx, loginReq)\n</code></pre>"},{"location":"authentication/basic-auth/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>resp, httpResp, err := client.Auth.Login(ctx, loginReq)\nif err != nil {\n    // Don't expose internal errors to end users\n    log.Printf(\"Login error: %v\", err)\n\n    // Return user-friendly message\n    if httpResp != nil &amp;&amp; httpResp.StatusCode == 401 {\n        return errors.New(\"invalid credentials\")\n    }\n    return errors.New(\"login failed, please try again\")\n}\n</code></pre>"},{"location":"authentication/basic-auth/#4-validate-input","title":"4. Validate Input","text":"<pre><code>func validateCredentials(email, password string) error {\n    if email == \"\" {\n        return errors.New(\"email is required\")\n    }\n    if !strings.Contains(email, \"@\") {\n        return errors.New(\"invalid email format\")\n    }\n    if len(password) &lt; 6 {\n        return errors.New(\"password must be at least 6 characters\")\n    }\n    return nil\n}\n</code></pre>"},{"location":"authentication/basic-auth/#5-secure-token-storage","title":"5. Secure Token Storage","text":"<pre><code>// For CLI applications\nfunc saveToken(token string) error {\n    home, _ := os.UserHomeDir()\n    tokenFile := filepath.Join(home, \".pipeops\", \"token\")\n\n    // Create directory with restricted permissions\n    os.MkdirAll(filepath.Dir(tokenFile), 0700)\n\n    // Write token with restricted permissions\n    return os.WriteFile(tokenFile, []byte(token), 0600)\n}\n\nfunc loadToken() (string, error) {\n    home, _ := os.UserHomeDir()\n    tokenFile := filepath.Join(home, \".pipeops\", \"token\")\n\n    data, err := os.ReadFile(tokenFile)\n    if err != nil {\n        return \"\", err\n    }\n\n    return string(data), nil\n}\n</code></pre>"},{"location":"authentication/basic-auth/#error-handling","title":"Error Handling","text":"<p>Common authentication errors:</p> <pre><code>resp, httpResp, err := client.Auth.Login(ctx, loginReq)\nif err != nil {\n    if httpResp != nil {\n        switch httpResp.StatusCode {\n        case 400:\n            fmt.Println(\"Invalid request format\")\n        case 401:\n            fmt.Println(\"Invalid email or password\")\n        case 403:\n            fmt.Println(\"Account is disabled\")\n        case 429:\n            fmt.Println(\"Too many login attempts\")\n        case 500:\n            fmt.Println(\"Server error\")\n        default:\n            fmt.Printf(\"Unexpected error: %d\\n\", httpResp.StatusCode)\n        }\n    }\n    return err\n}\n</code></pre>"},{"location":"authentication/basic-auth/#next-steps","title":"Next Steps","text":"<ul> <li>OAuth 2.0 - Learn about OAuth authentication</li> <li>Service Tokens - Use service account tokens</li> <li>Error Handling - Handle errors effectively</li> </ul>"},{"location":"authentication/oauth/","title":"OAuth 2.0 Authentication","text":"<p>The PipeOps Go SDK provides full support for OAuth 2.0 authorization code flow, enabling third-party applications to access the PipeOps API on behalf of users.</p>"},{"location":"authentication/oauth/#oauth-20-flow-overview","title":"OAuth 2.0 Flow Overview","text":"<ol> <li>Authorization - Direct user to authorization URL</li> <li>User Consent - User grants permission</li> <li>Callback - Receive authorization code</li> <li>Token Exchange - Exchange code for access token</li> <li>API Access - Use access token to make API calls</li> </ol>"},{"location":"authentication/oauth/#complete-oauth-example","title":"Complete OAuth Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nvar (\n    clientID     = \"your-oauth-client-id\"\n    clientSecret = \"your-oauth-client-secret\"\n    redirectURI  = \"http://localhost:3000/callback\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n\n    // Step 1: Generate authorization URL\n    authURL, err := client.OAuth.Authorize(&amp;pipeops.AuthorizeOptions{\n        ClientID:     clientID,\n        RedirectURI:  redirectURI,\n        ResponseType: \"code\",\n        Scope:        \"user:read user:write projects:read\",\n        State:        \"random-state-string\", // CSRF protection\n    })\n    if err != nil {\n        log.Fatalf(\"Failed to generate auth URL: %v\", err)\n    }\n\n    fmt.Printf(\"Visit this URL to authorize:\\n%s\\n\", authURL)\n\n    // Step 2: Set up callback handler\n    http.HandleFunc(\"/callback\", func(w http.ResponseWriter, r *http.Request) {\n        // Step 3: Extract authorization code\n        code := r.URL.Query().Get(\"code\")\n        state := r.URL.Query().Get(\"state\")\n\n        // Verify state to prevent CSRF\n        if state != \"random-state-string\" {\n            http.Error(w, \"Invalid state\", http.StatusBadRequest)\n            return\n        }\n\n        if code == \"\" {\n            http.Error(w, \"No code received\", http.StatusBadRequest)\n            return\n        }\n\n        // Step 4: Exchange code for token\n        ctx := context.Background()\n        token, _, err := client.OAuth.ExchangeCodeForToken(ctx, &amp;pipeops.TokenRequest{\n            GrantType:    \"authorization_code\",\n            Code:         code,\n            ClientID:     clientID,\n            ClientSecret: clientSecret,\n            RedirectURI:  redirectURI,\n        })\n        if err != nil {\n            log.Printf(\"Token exchange failed: %v\", err)\n            http.Error(w, \"Failed to exchange token\", http.StatusInternalServerError)\n            return\n        }\n\n        // Step 5: Use the access token\n        client.SetToken(token.AccessToken)\n\n        // Get user info\n        userInfo, _, err := client.OAuth.GetUserInfo(ctx)\n        if err != nil {\n            log.Printf(\"Failed to get user info: %v\", err)\n            http.Error(w, \"Failed to get user info\", http.StatusInternalServerError)\n            return\n        }\n\n        fmt.Fprintf(w, \"Authorized! User: %s (%s)\", userInfo.Data.Name, userInfo.Data.Email)\n    })\n\n    // Start server\n    log.Println(\"Starting server on :3000\")\n    log.Fatal(http.ListenAndServe(\":3000\", nil))\n}\n</code></pre>"},{"location":"authentication/oauth/#step-1-generate-authorization-url","title":"Step 1: Generate Authorization URL","text":"<p>Create a URL to redirect the user for authorization:</p> <pre><code>authURL, err := client.OAuth.Authorize(&amp;pipeops.AuthorizeOptions{\n    ClientID:     \"your-client-id\",\n    RedirectURI:  \"http://localhost:3000/callback\",\n    ResponseType: \"code\",\n    Scope:        \"user:read user:write\",\n    State:        \"random-secure-string\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to generate URL: %v\", err)\n}\n\n// Redirect user to authURL\nfmt.Printf(\"Authorization URL: %s\\n\", authURL)\n</code></pre>"},{"location":"authentication/oauth/#parameters","title":"Parameters","text":"Parameter Description Required <code>ClientID</code> Your OAuth application ID Yes <code>RedirectURI</code> Callback URL after authorization Yes <code>ResponseType</code> Set to \"code\" for authorization code flow Yes <code>Scope</code> Space-separated list of permissions No <code>State</code> Random string for CSRF protection Recommended"},{"location":"authentication/oauth/#available-scopes","title":"Available Scopes","text":"<ul> <li><code>user:read</code> - Read user profile information</li> <li><code>user:write</code> - Modify user profile</li> <li><code>projects:read</code> - Read project information</li> <li><code>projects:write</code> - Create and modify projects</li> <li><code>servers:read</code> - Read server information</li> <li><code>servers:write</code> - Create and modify servers</li> </ul>"},{"location":"authentication/oauth/#step-2-handle-callback","title":"Step 2: Handle Callback","text":"<p>After user authorization, handle the callback:</p> <pre><code>http.HandleFunc(\"/callback\", func(w http.ResponseWriter, r *http.Request) {\n    // Extract parameters\n    code := r.URL.Query().Get(\"code\")\n    state := r.URL.Query().Get(\"state\")\n    errorParam := r.URL.Query().Get(\"error\")\n\n    // Check for errors\n    if errorParam != \"\" {\n        errorDesc := r.URL.Query().Get(\"error_description\")\n        http.Error(w, fmt.Sprintf(\"Authorization error: %s - %s\", errorParam, errorDesc), http.StatusBadRequest)\n        return\n    }\n\n    // Verify state (CSRF protection)\n    if state != expectedState {\n        http.Error(w, \"State mismatch\", http.StatusBadRequest)\n        return\n    }\n\n    // Proceed with token exchange...\n})\n</code></pre>"},{"location":"authentication/oauth/#step-3-exchange-code-for-token","title":"Step 3: Exchange Code for Token","text":"<p>Exchange the authorization code for an access token:</p> <pre><code>ctx := context.Background()\n\ntoken, _, err := client.OAuth.ExchangeCodeForToken(ctx, &amp;pipeops.TokenRequest{\n    GrantType:    \"authorization_code\",\n    Code:         code,\n    ClientID:     clientID,\n    ClientSecret: clientSecret,\n    RedirectURI:  redirectURI,\n})\nif err != nil {\n    log.Fatalf(\"Token exchange failed: %v\", err)\n}\n\nfmt.Printf(\"Access Token: %s\\n\", token.AccessToken)\nfmt.Printf(\"Expires In: %d seconds\\n\", token.ExpiresIn)\nfmt.Printf(\"Refresh Token: %s\\n\", token.RefreshToken)\n</code></pre>"},{"location":"authentication/oauth/#token-response","title":"Token Response","text":"<pre><code>type TokenResponse struct {\n    AccessToken  string `json:\"access_token\"`\n    TokenType    string `json:\"token_type\"`      // \"Bearer\"\n    ExpiresIn    int    `json:\"expires_in\"`      // Seconds until expiration\n    RefreshToken string `json:\"refresh_token\"`   // Use to get new access token\n    Scope        string `json:\"scope\"`           // Granted scopes\n}\n</code></pre>"},{"location":"authentication/oauth/#step-4-use-access-token","title":"Step 4: Use Access Token","text":"<p>Set the token and make API calls:</p> <pre><code>// Set the access token\nclient.SetToken(token.AccessToken)\n\n// Make authenticated API calls\nctx := context.Background()\nprojects, _, err := client.Projects.List(ctx, nil)\nif err != nil {\n    log.Fatalf(\"Failed to list projects: %v\", err)\n}\n\nfmt.Printf(\"Found %d projects\\n\", len(projects.Data.Projects))\n</code></pre>"},{"location":"authentication/oauth/#get-user-information","title":"Get User Information","text":"<p>Retrieve information about the authenticated user:</p> <pre><code>userInfo, _, err := client.OAuth.GetUserInfo(ctx)\nif err != nil {\n    log.Fatalf(\"Failed to get user info: %v\", err)\n}\n\nfmt.Printf(\"User ID: %s\\n\", userInfo.Data.Sub)\nfmt.Printf(\"Email: %s\\n\", userInfo.Data.Email)\nfmt.Printf(\"Name: %s\\n\", userInfo.Data.Name)\nfmt.Printf(\"Email Verified: %t\\n\", userInfo.Data.EmailVerified)\n</code></pre>"},{"location":"authentication/oauth/#userinfo-response","title":"UserInfo Response","text":"<pre><code>type UserInfo struct {\n    Sub           string `json:\"sub\"`              // User ID\n    Email         string `json:\"email\"`\n    EmailVerified bool   `json:\"email_verified\"`\n    Name          string `json:\"name\"`\n    GivenName     string `json:\"given_name\"`\n    FamilyName    string `json:\"family_name\"`\n    Picture       string `json:\"picture\"`\n}\n</code></pre>"},{"location":"authentication/oauth/#refresh-tokens","title":"Refresh Tokens","text":"<p>Use a refresh token to get a new access token:</p> <pre><code>newToken, _, err := client.OAuth.ExchangeCodeForToken(ctx, &amp;pipeops.TokenRequest{\n    GrantType:    \"refresh_token\",\n    RefreshToken: storedRefreshToken,\n    ClientID:     clientID,\n    ClientSecret: clientSecret,\n})\nif err != nil {\n    log.Fatalf(\"Token refresh failed: %v\", err)\n}\n\n// Update the token\nclient.SetToken(newToken.AccessToken)\n\n// Store new refresh token\nstoredRefreshToken = newToken.RefreshToken\n</code></pre>"},{"location":"authentication/oauth/#token-management","title":"Token Management","text":""},{"location":"authentication/oauth/#store-tokens-securely","title":"Store Tokens Securely","text":"<pre><code>import (\n    \"encoding/json\"\n    \"os\"\n)\n\ntype TokenStorage struct {\n    AccessToken  string `json:\"access_token\"`\n    RefreshToken string `json:\"refresh_token\"`\n    ExpiresAt    int64  `json:\"expires_at\"`\n}\n\nfunc saveTokens(token *pipeops.TokenResponse) error {\n    storage := TokenStorage{\n        AccessToken:  token.AccessToken,\n        RefreshToken: token.RefreshToken,\n        ExpiresAt:    time.Now().Unix() + int64(token.ExpiresIn),\n    }\n\n    data, _ := json.Marshal(storage)\n    return os.WriteFile(\"tokens.json\", data, 0600)\n}\n\nfunc loadTokens() (*TokenStorage, error) {\n    data, err := os.ReadFile(\"tokens.json\")\n    if err != nil {\n        return nil, err\n    }\n\n    var storage TokenStorage\n    err = json.Unmarshal(data, &amp;storage)\n    return &amp;storage, err\n}\n</code></pre>"},{"location":"authentication/oauth/#automatic-token-refresh","title":"Automatic Token Refresh","text":"<pre><code>type OAuthClient struct {\n    client       *pipeops.Client\n    accessToken  string\n    refreshToken string\n    expiresAt    time.Time\n    mu           sync.RWMutex\n}\n\nfunc (oc *OAuthClient) GetToken(ctx context.Context) (string, error) {\n    oc.mu.RLock()\n    // Check if token is still valid\n    if time.Now().Before(oc.expiresAt.Add(-5 * time.Minute)) {\n        token := oc.accessToken\n        oc.mu.RUnlock()\n        return token, nil\n    }\n    oc.mu.RUnlock()\n\n    // Need to refresh\n    return oc.refreshAccessToken(ctx)\n}\n\nfunc (oc *OAuthClient) refreshAccessToken(ctx context.Context) (string, error) {\n    oc.mu.Lock()\n    defer oc.mu.Unlock()\n\n    // Double-check after acquiring lock\n    if time.Now().Before(oc.expiresAt.Add(-5 * time.Minute)) {\n        return oc.accessToken, nil\n    }\n\n    // Refresh the token\n    newToken, _, err := oc.client.OAuth.ExchangeCodeForToken(ctx, &amp;pipeops.TokenRequest{\n        GrantType:    \"refresh_token\",\n        RefreshToken: oc.refreshToken,\n        ClientID:     clientID,\n        ClientSecret: clientSecret,\n    })\n    if err != nil {\n        return \"\", err\n    }\n\n    // Update stored tokens\n    oc.accessToken = newToken.AccessToken\n    oc.refreshToken = newToken.RefreshToken\n    oc.expiresAt = time.Now().Add(time.Duration(newToken.ExpiresIn) * time.Second)\n    oc.client.SetToken(newToken.AccessToken)\n\n    return oc.accessToken, nil\n}\n</code></pre>"},{"location":"authentication/oauth/#security-best-practices","title":"Security Best Practices","text":""},{"location":"authentication/oauth/#1-use-state-parameter","title":"1. Use State Parameter","text":"<p>Always use a state parameter to prevent CSRF attacks:</p> <pre><code>import \"crypto/rand\"\nimport \"encoding/hex\"\n\nfunc generateState() string {\n    b := make([]byte, 16)\n    rand.Read(b)\n    return hex.EncodeToString(b)\n}\n\nstate := generateState()\n// Store state in session for verification\n\nauthURL, _ := client.OAuth.Authorize(&amp;pipeops.AuthorizeOptions{\n    State: state,\n    // ... other params\n})\n</code></pre>"},{"location":"authentication/oauth/#2-use-https","title":"2. Use HTTPS","text":"<p>Always use HTTPS for redirect URIs in production:</p> <pre><code>// \u2705 Good\nredirectURI := \"https://myapp.com/callback\"\n\n// \u274c Bad (only for local development)\nredirectURI := \"http://localhost:3000/callback\"\n</code></pre>"},{"location":"authentication/oauth/#3-secure-token-storage","title":"3. Secure Token Storage","text":"<p>Never store tokens in plain text:</p> <pre><code>// Use secure storage mechanisms\nimport \"github.com/zalando/go-keyring\"\n\nfunc storeToken(token string) error {\n    return keyring.Set(\"myapp\", \"oauth-token\", token)\n}\n\nfunc getToken() (string, error) {\n    return keyring.Get(\"myapp\", \"oauth-token\")\n}\n</code></pre>"},{"location":"authentication/oauth/#4-validate-redirect-uri","title":"4. Validate Redirect URI","text":"<p>Ensure the redirect URI matches exactly:</p> <pre><code>const registeredRedirectURI = \"https://myapp.com/callback\"\n\nif redirectURI != registeredRedirectURI {\n    return errors.New(\"invalid redirect URI\")\n}\n</code></pre>"},{"location":"authentication/oauth/#error-handling","title":"Error Handling","text":"<pre><code>token, resp, err := client.OAuth.ExchangeCodeForToken(ctx, tokenReq)\nif err != nil {\n    if resp != nil {\n        switch resp.StatusCode {\n        case 400:\n            log.Println(\"Invalid request - check parameters\")\n        case 401:\n            log.Println(\"Invalid client credentials\")\n        case 403:\n            log.Println(\"Access denied\")\n        default:\n            log.Printf(\"Token exchange failed: %v\", err)\n        }\n    }\n    return err\n}\n</code></pre>"},{"location":"authentication/oauth/#complete-example","title":"Complete Example","text":"<p>See the examples/oauth directory for a complete working OAuth implementation.</p>"},{"location":"authentication/oauth/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Authentication - Learn about email/password auth</li> <li>API Services - Explore available API services</li> <li>Error Handling - Handle errors effectively</li> </ul>"},{"location":"authentication/overview/","title":"Authentication Overview","text":"<p>The PipeOps Go SDK supports multiple authentication methods to suit different use cases. All authenticated requests include an authentication token in the request headers.</p>"},{"location":"authentication/overview/#authentication-methods","title":"Authentication Methods","text":""},{"location":"authentication/overview/#1-emailpassword-authentication","title":"1. Email/Password Authentication","text":"<p>The most common method - authenticate with email and password to receive a token:</p> <pre><code>loginResp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n    Email:    \"user@example.com\",\n    Password: \"your-password\",\n})\n\nclient.SetToken(loginResp.Data.Token)\n</code></pre> <p>Use Case: User-facing applications, interactive tools</p> <p>See: Basic Authentication Guide</p>"},{"location":"authentication/overview/#2-oauth-20","title":"2. OAuth 2.0","text":"<p>Use OAuth 2.0 authorization code flow for third-party integrations:</p> <pre><code>// Generate authorization URL\nauthURL, _ := client.OAuth.Authorize(&amp;pipeops.AuthorizeOptions{\n    ClientID:     \"your-client-id\",\n    RedirectURI:  \"http://localhost:3000/callback\",\n    ResponseType: \"code\",\n    Scope:        \"user:read user:write\",\n})\n\n// After user authorization, exchange code for token\ntoken, _, _ := client.OAuth.ExchangeCodeForToken(ctx, &amp;pipeops.TokenRequest{\n    GrantType:    \"authorization_code\",\n    Code:         authCode,\n    ClientID:     \"your-client-id\",\n    ClientSecret: \"your-client-secret\",\n})\n\nclient.SetToken(token.AccessToken)\n</code></pre> <p>Use Case: Third-party integrations, delegated access</p> <p>See: OAuth 2.0 Guide</p>"},{"location":"authentication/overview/#3-existing-token","title":"3. Existing Token","text":"<p>If you already have a valid token, use it directly:</p> <pre><code>client.SetToken(\"your-existing-token\")\n</code></pre> <p>Use Case: Service accounts, automation scripts, token refresh flows</p>"},{"location":"authentication/overview/#token-management","title":"Token Management","text":""},{"location":"authentication/overview/#setting-a-token","title":"Setting a Token","text":"<pre><code>// After authentication\nclient.SetToken(token)\n</code></pre>"},{"location":"authentication/overview/#token-lifecycle","title":"Token Lifecycle","text":"<p>Tokens returned by the API have a limited lifetime. Handle token expiration:</p> <pre><code>// Check if request failed due to authentication\nprojects, resp, err := client.Projects.List(ctx, nil)\nif err != nil &amp;&amp; resp != nil &amp;&amp; resp.StatusCode == 401 {\n    // Token expired or invalid - re-authenticate\n    loginResp, _, _ := client.Auth.Login(ctx, loginReq)\n    client.SetToken(loginResp.Data.Token)\n\n    // Retry the request\n    projects, resp, err = client.Projects.List(ctx, nil)\n}\n</code></pre>"},{"location":"authentication/overview/#token-storage","title":"Token Storage","text":"<p>Security Best Practice</p> <p>Never hardcode tokens in your source code. Use environment variables or secure storage.</p> <pre><code>import \"os\"\n\n// Load token from environment\ntoken := os.Getenv(\"PIPEOPS_TOKEN\")\nif token != \"\" {\n    client.SetToken(token)\n}\n</code></pre>"},{"location":"authentication/overview/#authentication-flow-examples","title":"Authentication Flow Examples","text":""},{"location":"authentication/overview/#interactive-application","title":"Interactive Application","text":"<pre><code>func authenticateUser(client *pipeops.Client, email, password string) (string, error) {\n    ctx := context.Background()\n\n    resp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    email,\n        Password: password,\n    })\n    if err != nil {\n        return \"\", fmt.Errorf(\"login failed: %w\", err)\n    }\n\n    // Store token for subsequent requests\n    client.SetToken(resp.Data.Token)\n\n    return resp.Data.Token, nil\n}\n</code></pre>"},{"location":"authentication/overview/#service-account","title":"Service Account","text":"<pre><code>func setupServiceClient() (*pipeops.Client, error) {\n    client, _ := pipeops.NewClient(\"\")\n\n    // Load service token from environment\n    token := os.Getenv(\"PIPEOPS_SERVICE_TOKEN\")\n    if token == \"\" {\n        return nil, errors.New(\"PIPEOPS_SERVICE_TOKEN not set\")\n    }\n\n    client.SetToken(token)\n    return client, nil\n}\n</code></pre>"},{"location":"authentication/overview/#token-refresh-pattern","title":"Token Refresh Pattern","text":"<pre><code>type AuthManager struct {\n    client   *pipeops.Client\n    email    string\n    password string\n    token    string\n    mu       sync.RWMutex\n}\n\nfunc (am *AuthManager) GetToken(ctx context.Context) (string, error) {\n    am.mu.RLock()\n    token := am.token\n    am.mu.RUnlock()\n\n    if token != \"\" {\n        return token, nil\n    }\n\n    // Need to authenticate\n    return am.refreshToken(ctx)\n}\n\nfunc (am *AuthManager) refreshToken(ctx context.Context) (string, error) {\n    am.mu.Lock()\n    defer am.mu.Unlock()\n\n    resp, _, err := am.client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    am.email,\n        Password: am.password,\n    })\n    if err != nil {\n        return \"\", err\n    }\n\n    am.token = resp.Data.Token\n    am.client.SetToken(am.token)\n\n    return am.token, nil\n}\n</code></pre>"},{"location":"authentication/overview/#security-best-practices","title":"Security Best Practices","text":""},{"location":"authentication/overview/#1-protect-credentials","title":"1. Protect Credentials","text":"<pre><code>// \u2705 Good - Use environment variables\nemail := os.Getenv(\"PIPEOPS_EMAIL\")\npassword := os.Getenv(\"PIPEOPS_PASSWORD\")\n\n// \u274c Bad - Hardcoded credentials\nemail := \"user@example.com\"\npassword := \"hardcoded-password\"\n</code></pre>"},{"location":"authentication/overview/#2-use-context-timeouts","title":"2. Use Context Timeouts","text":"<pre><code>// Set timeout for authentication\nctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\n\nresp, _, err := client.Auth.Login(ctx, loginReq)\n</code></pre>"},{"location":"authentication/overview/#3-handle-authentication-errors","title":"3. Handle Authentication Errors","text":"<pre><code>resp, _, err := client.Auth.Login(ctx, loginReq)\nif err != nil {\n    // Don't expose sensitive error details to end users\n    log.Printf(\"Authentication failed: %v\", err)\n    return errors.New(\"authentication failed\")\n}\n</code></pre>"},{"location":"authentication/overview/#4-validate-input","title":"4. Validate Input","text":"<pre><code>func login(email, password string) error {\n    // Validate before making request\n    if email == \"\" || password == \"\" {\n        return errors.New(\"email and password required\")\n    }\n\n    if !strings.Contains(email, \"@\") {\n        return errors.New(\"invalid email format\")\n    }\n\n    // Proceed with login\n    resp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    email,\n        Password: password,\n    })\n    // ...\n}\n</code></pre>"},{"location":"authentication/overview/#5-secure-token-storage","title":"5. Secure Token Storage","text":"<p>For persistent storage, use secure methods:</p> <pre><code>import \"github.com/zalando/go-keyring\"\n\n// Store token securely\nfunc storeToken(token string) error {\n    return keyring.Set(\"pipeops-app\", \"api-token\", token)\n}\n\n// Retrieve token\nfunc getToken() (string, error) {\n    return keyring.Get(\"pipeops-app\", \"api-token\")\n}\n</code></pre>"},{"location":"authentication/overview/#authentication-errors","title":"Authentication Errors","text":"<p>Common authentication errors and how to handle them:</p> Error Description Solution 401 Unauthorized Invalid or expired token Re-authenticate and get a new token 400 Bad Request Invalid credentials Check email/password format 429 Too Many Requests Rate limited Wait before retrying (check Retry-After header) 500 Server Error Server issue Retry with exponential backoff"},{"location":"authentication/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Authentication - Detailed email/password authentication guide</li> <li>OAuth 2.0 - Complete OAuth integration guide</li> <li>Service Tokens - Learn about service account tokens</li> </ul>"},{"location":"examples/common-patterns/","title":"Common Patterns","text":"<p>Common patterns and best practices for using the SDK.</p>"},{"location":"examples/common-patterns/#pagination","title":"Pagination","text":"<p>Handle paginated results:</p> <pre><code>func getAllProjects(client *pipeops.Client, ctx context.Context) ([]pipeops.Project, error) {\n    var allProjects []pipeops.Project\n    page := 1\n    limit := 100\n\n    for {\n        projects, _, err := client.Projects.List(ctx, &amp;pipeops.ProjectListOptions{\n            Page:  page,\n            Limit: limit,\n        })\n        if err != nil {\n            return nil, err\n        }\n\n        allProjects = append(allProjects, projects.Data.Projects...)\n\n        // Check if there are more pages\n        if len(projects.Data.Projects) &lt; limit {\n            break\n        }\n\n        page++\n    }\n\n    return allProjects, nil\n}\n</code></pre>"},{"location":"examples/common-patterns/#bulk-operations","title":"Bulk Operations","text":"<p>Process multiple resources:</p> <pre><code>func deployAllProjects(client *pipeops.Client, ctx context.Context, projectUUIDs []string) error {\n    for _, uuid := range projectUUIDs {\n        _, _, err := client.Projects.Deploy(ctx, uuid)\n        if err != nil {\n            log.Printf(\"Failed to deploy %s: %v\", uuid, err)\n            continue\n        }\n\n        fmt.Printf(\"Deployed: %s\\n\", uuid)\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"examples/common-patterns/#concurrent-operations","title":"Concurrent Operations","text":"<p>Execute operations concurrently:</p> <pre><code>func deployProjectsConcurrently(client *pipeops.Client, ctx context.Context, projectUUIDs []string) {\n    var wg sync.WaitGroup\n\n    for _, uuid := range projectUUIDs {\n        wg.Add(1)\n        go func(projectUUID string) {\n            defer wg.Done()\n\n            _, _, err := client.Projects.Deploy(ctx, projectUUID)\n            if err != nil {\n                log.Printf(\"Failed to deploy %s: %v\", projectUUID, err)\n                return\n            }\n\n            fmt.Printf(\"Deployed: %s\\n\", projectUUID)\n        }(uuid)\n    }\n\n    wg.Wait()\n}\n</code></pre>"},{"location":"examples/common-patterns/#resource-polling","title":"Resource Polling","text":"<p>Poll for resource state changes:</p> <pre><code>func waitForDeployment(client *pipeops.Client, ctx context.Context, projectUUID string) error {\n    ticker := time.NewTicker(10 * time.Second)\n    defer ticker.Stop()\n\n    timeout := time.After(10 * time.Minute)\n\n    for {\n        select {\n        case &lt;-timeout:\n            return fmt.Errorf(\"deployment timeout\")\n\n        case &lt;-ticker.C:\n            project, _, err := client.Projects.Get(ctx, projectUUID)\n            if err != nil {\n                return err\n            }\n\n            status := project.Data.Project.Status\n            if status == \"deployed\" {\n                return nil\n            } else if status == \"failed\" {\n                return fmt.Errorf(\"deployment failed\")\n            }\n\n            fmt.Printf(\"Status: %s\\n\", status)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/common-patterns/#caching","title":"Caching","text":"<p>Cache frequently accessed data:</p> <pre><code>type CachedClient struct {\n    client *pipeops.Client\n    cache  map[string]interface{}\n    mu     sync.RWMutex\n}\n\nfunc (c *CachedClient) GetProject(ctx context.Context, uuid string) (*pipeops.Project, error) {\n    c.mu.RLock()\n    if cached, ok := c.cache[uuid]; ok {\n        c.mu.RUnlock()\n        return cached.(*pipeops.Project), nil\n    }\n    c.mu.RUnlock()\n\n    project, _, err := c.client.Projects.Get(ctx, uuid)\n    if err != nil {\n        return nil, err\n    }\n\n    c.mu.Lock()\n    c.cache[uuid] = &amp;project.Data.Project\n    c.mu.Unlock()\n\n    return &amp;project.Data.Project, nil\n}\n</code></pre>"},{"location":"examples/complete-examples/","title":"Complete Examples","text":"<p>Real-world examples demonstrating SDK usage.</p>"},{"location":"examples/complete-examples/#cicd-integration","title":"CI/CD Integration","text":"<p>Automate deployments from CI/CD pipelines:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    // Get credentials from environment\n    token := os.Getenv(\"PIPEOPS_TOKEN\")\n    projectUUID := os.Getenv(\"PROJECT_UUID\")\n\n    if token == \"\" || projectUUID == \"\" {\n        log.Fatal(\"PIPEOPS_TOKEN and PROJECT_UUID required\")\n    }\n\n    // Create client\n    client, _ := pipeops.NewClient(\"\")\n    client.SetToken(token)\n\n    ctx := context.Background()\n\n    // Deploy project\n    fmt.Println(\"Starting deployment...\")\n    deployment, _, err := client.Projects.Deploy(ctx, projectUUID)\n    if err != nil {\n        log.Fatalf(\"Deployment failed: %v\", err)\n    }\n\n    fmt.Printf(\"Deployment started: %s\\n\", deployment.Data.DeploymentID)\n\n    // Wait for deployment to complete\n    // (Implementation depends on your needs)\n\n    fmt.Println(\"Deployment complete!\")\n}\n</code></pre>"},{"location":"examples/complete-examples/#infrastructure-management","title":"Infrastructure Management","text":"<p>Manage servers and projects:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n    client.SetToken(\"your-token\")\n\n    ctx := context.Background()\n\n    // Create server\n    server, _, err := client.Servers.Create(ctx, &amp;pipeops.CreateServerRequest{\n        Name:     \"Production\",\n        Provider: \"aws\",\n        Region:   \"us-east-1\",\n    })\n    if err != nil {\n        log.Fatalf(\"Failed to create server: %v\", err)\n    }\n\n    serverUUID := server.Data.Server.UUID\n    fmt.Printf(\"Created server: %s\\n\", serverUUID)\n\n    // Create project on server\n    project, _, err := client.Projects.Create(ctx, &amp;pipeops.CreateProjectRequest{\n        Name:       \"My App\",\n        ServerID:   serverUUID,\n        Repository: \"https://github.com/user/app\",\n        Branch:     \"main\",\n    })\n    if err != nil {\n        log.Fatalf(\"Failed to create project: %v\", err)\n    }\n\n    fmt.Printf(\"Created project: %s\\n\", project.Data.Project.UUID)\n}\n</code></pre>"},{"location":"examples/complete-examples/#monitoring-and-alerts","title":"Monitoring and Alerts","text":"<p>Monitor project logs and metrics:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n    client.SetToken(\"your-token\")\n\n    projectUUID := \"project-uuid\"\n    ctx := context.Background()\n\n    // Poll logs every 30 seconds\n    ticker := time.NewTicker(30 * time.Second)\n    defer ticker.Stop()\n\n    for range ticker.C {\n        logs, _, err := client.Projects.GetLogs(ctx, projectUUID, &amp;pipeops.LogsOptions{\n            Limit:  100,\n            Search: \"error\",\n        })\n        if err != nil {\n            log.Printf(\"Failed to get logs: %v\", err)\n            continue\n        }\n\n        if len(logs.Data.Logs) &gt; 0 {\n            fmt.Printf(\"Found %d errors\\n\", len(logs.Data.Logs))\n            // Send alert\n        }\n    }\n}\n</code></pre>"},{"location":"examples/complete-examples/#see-also","title":"See Also","text":"<ul> <li>Basic Example</li> <li>OAuth Example</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>The PipeOps Go SDK uses the functional options pattern for flexible configuration. This guide covers all available configuration options.</p>"},{"location":"getting-started/configuration/#basic-configuration","title":"Basic Configuration","text":"<pre><code>import (\n    \"time\"\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nclient, err := pipeops.NewClient(\"\",\n    pipeops.WithTimeout(30*time.Second),\n    pipeops.WithMaxRetries(3),\n)\n</code></pre>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/configuration/#base-url","title":"Base URL","text":"<p>Set a custom API endpoint (useful for testing or staging environments):</p> <pre><code>// Use default production URL\nclient, _ := pipeops.NewClient(\"\")\n\n// Use custom URL\nclient, _ := pipeops.NewClient(\"https://staging-api.pipeops.io\")\n</code></pre> <p>Default: <code>https://api.pipeops.io</code></p>"},{"location":"getting-started/configuration/#timeout","title":"Timeout","text":"<p>Set the maximum duration for requests:</p> <pre><code>client, _ := pipeops.NewClient(\"\",\n    pipeops.WithTimeout(60*time.Second), // 60 second timeout\n)\n</code></pre> <p>Default: 30 seconds</p> <p>Recommendation:  - Use shorter timeouts (10-30s) for interactive applications - Use longer timeouts (60-120s) for batch operations</p>"},{"location":"getting-started/configuration/#max-retries","title":"Max Retries","text":"<p>Configure automatic retry behavior for failed requests:</p> <pre><code>client, _ := pipeops.NewClient(\"\",\n    pipeops.WithMaxRetries(5), // Retry up to 5 times\n)\n</code></pre> <p>Default: 3 retries</p> <p>The SDK automatically retries: - Network errors (connection timeouts, DNS failures) - HTTP 5xx server errors - HTTP 429 rate limit errors</p> <p>Retries use exponential backoff with jitter.</p>"},{"location":"getting-started/configuration/#user-agent","title":"User Agent","text":"<p>Set a custom user agent string:</p> <pre><code>client, _ := pipeops.NewClient(\"\",\n    pipeops.WithUserAgent(\"my-app/1.0.0\"),\n)\n</code></pre> <p>Default: <code>pipeops-go-sdk/1.0.0</code></p> <p>Best Practice: Include your application name and version for better tracking and debugging.</p>"},{"location":"getting-started/configuration/#custom-http-client","title":"Custom HTTP Client","text":"<p>Use your own configured HTTP client:</p> <pre><code>import (\n    \"net/http\"\n    \"time\"\n)\n\ncustomClient := &amp;http.Client{\n    Timeout: 90 * time.Second,\n    Transport: &amp;http.Transport{\n        MaxIdleConns:        100,\n        MaxIdleConnsPerHost: 10,\n        IdleConnTimeout:     90 * time.Second,\n        DisableCompression:  false,\n        DisableKeepAlives:   false,\n    },\n}\n\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithHTTPClient(customClient),\n)\n</code></pre> <p>Use Cases: - Custom TLS configuration - Proxy support - Connection pooling tuning - Custom transport middleware</p>"},{"location":"getting-started/configuration/#logger","title":"Logger","text":"<p>Add logging for debugging and monitoring:</p> <pre><code>import \"log\"\n\ntype MyLogger struct{}\n\nfunc (l *MyLogger) Debug(msg string, keysAndValues ...interface{}) {\n    log.Printf(\"[DEBUG] %s %v\", msg, keysAndValues)\n}\n\nfunc (l *MyLogger) Info(msg string, keysAndValues ...interface{}) {\n    log.Printf(\"[INFO] %s %v\", msg, keysAndValues)\n}\n\nfunc (l *MyLogger) Warn(msg string, keysAndValues ...interface{}) {\n    log.Printf(\"[WARN] %s %v\", msg, keysAndValues)\n}\n\nfunc (l *MyLogger) Error(msg string, keysAndValues ...interface{}) {\n    log.Printf(\"[ERROR] %s %v\", msg, keysAndValues)\n}\n\n// Use the logger\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithLogger(&amp;MyLogger{}),\n)\n</code></pre>"},{"location":"getting-started/configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<p>Here's a production-ready configuration:</p> <pre><code>package main\n\nimport (\n    \"crypto/tls\"\n    \"log\"\n    \"net/http\"\n    \"time\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    // Custom HTTP transport with TLS configuration\n    transport := &amp;http.Transport{\n        MaxIdleConns:        100,\n        MaxIdleConnsPerHost: 10,\n        IdleConnTimeout:     90 * time.Second,\n        TLSClientConfig: &amp;tls.Config{\n            MinVersion: tls.VersionTLS12,\n        },\n        DisableCompression: false,\n    }\n\n    // Custom HTTP client\n    httpClient := &amp;http.Client{\n        Timeout:   60 * time.Second,\n        Transport: transport,\n    }\n\n    // Create SDK client with all options\n    client, err := pipeops.NewClient(\"https://api.pipeops.io\",\n        pipeops.WithHTTPClient(httpClient),\n        pipeops.WithTimeout(60*time.Second),\n        pipeops.WithMaxRetries(5),\n        pipeops.WithUserAgent(\"my-production-app/2.0.0\"),\n        pipeops.WithLogger(&amp;MyLogger{}),\n    )\n    if err != nil {\n        log.Fatalf(\"Failed to create client: %v\", err)\n    }\n\n    // Use the client\n    log.Println(\"Client configured successfully\")\n}\n</code></pre>"},{"location":"getting-started/configuration/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>Configure based on environment:</p> <pre><code>package main\n\nimport (\n    \"os\"\n    \"time\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc createClient() (*pipeops.Client, error) {\n    // Base URL from environment\n    baseURL := os.Getenv(\"PIPEOPS_API_URL\")\n    if baseURL == \"\" {\n        baseURL = \"https://api.pipeops.io\" // Default\n    }\n\n    // Timeout from environment\n    timeout := 30 * time.Second\n    if timeoutStr := os.Getenv(\"PIPEOPS_TIMEOUT\"); timeoutStr != \"\" {\n        if d, err := time.ParseDuration(timeoutStr); err == nil {\n            timeout = d\n        }\n    }\n\n    return pipeops.NewClient(baseURL,\n        pipeops.WithTimeout(timeout),\n        pipeops.WithMaxRetries(3),\n    )\n}\n</code></pre>"},{"location":"getting-started/configuration/#proxy-configuration","title":"Proxy Configuration","text":"<p>Configure an HTTP proxy:</p> <pre><code>import (\n    \"net/http\"\n    \"net/url\"\n)\n\n// Parse proxy URL\nproxyURL, _ := url.Parse(\"http://proxy.example.com:8080\")\n\n// Create transport with proxy\ntransport := &amp;http.Transport{\n    Proxy: http.ProxyURL(proxyURL),\n}\n\nhttpClient := &amp;http.Client{\n    Transport: transport,\n}\n\n// Use with SDK\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithHTTPClient(httpClient),\n)\n</code></pre>"},{"location":"getting-started/configuration/#tls-configuration","title":"TLS Configuration","text":"<p>Custom TLS settings:</p> <pre><code>import (\n    \"crypto/tls\"\n    \"net/http\"\n)\n\n// Custom TLS config\ntlsConfig := &amp;tls.Config{\n    MinVersion:         tls.VersionTLS12,\n    InsecureSkipVerify: false, // Always verify in production!\n}\n\ntransport := &amp;http.Transport{\n    TLSClientConfig: tlsConfig,\n}\n\nhttpClient := &amp;http.Client{\n    Transport: transport,\n}\n\nclient, _ := pipeops.NewClient(\"\",\n    pipeops.WithHTTPClient(httpClient),\n)\n</code></pre>"},{"location":"getting-started/configuration/#token-management","title":"Token Management","text":"<p>Setting and updating authentication tokens:</p> <pre><code>// Set token after login\nclient.SetToken(\"your-auth-token\")\n\n// Update token when it changes\nclient.SetToken(\"new-refreshed-token\")\n\n// Token is automatically included in all requests\n</code></pre>"},{"location":"getting-started/configuration/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/configuration/#production-configuration","title":"Production Configuration","text":"<pre><code>client, _ := pipeops.NewClient(\"\",\n    pipeops.WithTimeout(45*time.Second),      // Reasonable timeout\n    pipeops.WithMaxRetries(5),                // Handle transient failures\n    pipeops.WithUserAgent(\"app/1.0.0\"),       // Track your application\n    pipeops.WithLogger(productionLogger),     // Monitor API calls\n)\n</code></pre>"},{"location":"getting-started/configuration/#development-configuration","title":"Development Configuration","text":"<pre><code>client, _ := pipeops.NewClient(\"https://staging-api.pipeops.io\",\n    pipeops.WithTimeout(60*time.Second),      // Longer timeout for debugging\n    pipeops.WithMaxRetries(1),                // Fail fast for debugging\n    pipeops.WithLogger(debugLogger),          // Verbose logging\n)\n</code></pre>"},{"location":"getting-started/configuration/#testing-configuration","title":"Testing Configuration","text":"<pre><code>client, _ := pipeops.NewClient(\"http://localhost:8080\",\n    pipeops.WithTimeout(5*time.Second),       // Short timeout\n    pipeops.WithMaxRetries(0),                // No retries in tests\n)\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Make your first API call</li> <li>Authentication - Learn about authentication</li> <li>Error Handling - Handle errors and retries</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Go 1.19 or higher</li> <li>Git (for go get)</li> </ul>"},{"location":"getting-started/installation/#install-via-go-get","title":"Install via go get","text":"<p>The simplest way to install the PipeOps Go SDK is using <code>go get</code>:</p> <pre><code>go get github.com/PipeOpsHQ/pipeops-go-sdk\n</code></pre> <p>This will download the SDK and its dependencies into your Go workspace.</p>"},{"location":"getting-started/installation/#install-a-specific-version","title":"Install a Specific Version","text":"<p>To install a specific version of the SDK:</p> <pre><code>go get github.com/PipeOpsHQ/pipeops-go-sdk@v1.0.0\n</code></pre>"},{"location":"getting-started/installation/#using-go-modules","title":"Using Go Modules","text":"<p>If you're using Go modules (recommended), simply import the package in your code:</p> <pre><code>import \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n</code></pre> <p>Then run:</p> <pre><code>go mod tidy\n</code></pre> <p>This will automatically download the SDK and add it to your <code>go.mod</code> file.</p>"},{"location":"getting-started/installation/#manual-installation","title":"Manual Installation","text":"<p>You can also manually clone the repository:</p> <pre><code>git clone https://github.com/PipeOpsHQ/pipeops-go-sdk.git\ncd pipeops-go-sdk\ngo install\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test file to verify the installation:</p> test.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, err := pipeops.NewClient(\"\")\n    if err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"Client created successfully: %T\\n\", client)\n}\n</code></pre> <p>Run the test:</p> <pre><code>go run test.go\n</code></pre> <p>You should see output like:</p> <pre><code>Client created successfully: *pipeops.Client\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>The SDK has minimal dependencies:</p> <ul> <li><code>github.com/google/go-querystring</code> - URL query string encoding</li> </ul> <p>All dependencies are automatically managed by Go modules.</p>"},{"location":"getting-started/installation/#updating-the-sdk","title":"Updating the SDK","text":"<p>To update to the latest version:</p> <pre><code>go get -u github.com/PipeOpsHQ/pipeops-go-sdk\n</code></pre> <p>Or to update to a specific version:</p> <pre><code>go get -u github.com/PipeOpsHQ/pipeops-go-sdk@v1.1.0\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have the SDK installed, proceed to the Quick Start Guide to learn how to use it.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you make your first API call with the PipeOps Go SDK in just a few minutes.</p>"},{"location":"getting-started/quickstart/#basic-example","title":"Basic Example","text":"<p>Here's a complete example showing authentication and listing projects:</p> main.go<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    // Create a new client\n    client, err := pipeops.NewClient(\"\",\n        pipeops.WithTimeout(30*time.Second),\n        pipeops.WithMaxRetries(3),\n    )\n    if err != nil {\n        log.Fatalf(\"Failed to create client: %v\", err)\n    }\n\n    // Create a context with timeout\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    // Login to authenticate\n    loginResp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    \"your-email@example.com\",\n        Password: \"your-password\",\n    })\n    if err != nil {\n        log.Fatalf(\"Login failed: %v\", err)\n    }\n\n    fmt.Printf(\"Login successful! User: %s\\n\", loginResp.Data.User.Email)\n\n    // Set authentication token for subsequent requests\n    client.SetToken(loginResp.Data.Token)\n\n    // List all projects\n    projects, _, err := client.Projects.List(ctx, nil)\n    if err != nil {\n        log.Fatalf(\"Failed to list projects: %v\", err)\n    }\n\n    fmt.Printf(\"\\nFound %d projects:\\n\", len(projects.Data.Projects))\n    for _, project := range projects.Data.Projects {\n        fmt.Printf(\"  - %s (%s)\\n\", project.Name, project.UUID)\n    }\n}\n</code></pre>"},{"location":"getting-started/quickstart/#step-by-step-explanation","title":"Step-by-Step Explanation","text":""},{"location":"getting-started/quickstart/#1-create-a-client","title":"1. Create a Client","text":"<pre><code>client, err := pipeops.NewClient(\"\",\n    pipeops.WithTimeout(30*time.Second),\n    pipeops.WithMaxRetries(3),\n)\n</code></pre> <p>The client is your main interface to the PipeOps API. Pass an empty string to use the default API URL, or provide a custom URL for testing/staging environments.</p> <p>Configuration Options: - <code>WithTimeout()</code> - Set request timeout (default: 30s) - <code>WithMaxRetries()</code> - Set maximum retry attempts (default: 3) - <code>WithUserAgent()</code> - Set custom user agent - <code>WithLogger()</code> - Add logging support - <code>WithHTTPClient()</code> - Use a custom HTTP client</p>"},{"location":"getting-started/quickstart/#2-authenticate","title":"2. Authenticate","text":"<pre><code>loginResp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n    Email:    \"your-email@example.com\",\n    Password: \"your-password\",\n})\n</code></pre> <p>All API calls (except authentication) require a valid authentication token. The <code>Login</code> method returns a token in the response.</p>"},{"location":"getting-started/quickstart/#3-set-the-token","title":"3. Set the Token","text":"<pre><code>client.SetToken(loginResp.Data.Token)\n</code></pre> <p>After authentication, set the token on the client. It will be automatically included in all subsequent requests.</p>"},{"location":"getting-started/quickstart/#4-make-api-calls","title":"4. Make API Calls","text":"<pre><code>projects, _, err := client.Projects.List(ctx, nil)\n</code></pre> <p>Now you can call any API method. Most methods return three values: 1. Response data (specific to the endpoint) 2. Raw HTTP response (<code>*http.Response</code>) 3. Error (if any)</p>"},{"location":"getting-started/quickstart/#using-environment-variables","title":"Using Environment Variables","text":"<p>For better security, store credentials in environment variables:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/PipeOpsHQ/pipeops-go-sdk/pipeops\"\n)\n\nfunc main() {\n    client, _ := pipeops.NewClient(\"\")\n\n    // Get credentials from environment\n    email := os.Getenv(\"PIPEOPS_EMAIL\")\n    password := os.Getenv(\"PIPEOPS_PASSWORD\")\n\n    if email == \"\" || password == \"\" {\n        log.Fatal(\"Please set PIPEOPS_EMAIL and PIPEOPS_PASSWORD\")\n    }\n\n    ctx := context.Background()\n    loginResp, _, err := client.Auth.Login(ctx, &amp;pipeops.LoginRequest{\n        Email:    email,\n        Password: password,\n    })\n    if err != nil {\n        log.Fatalf(\"Login failed: %v\", err)\n    }\n\n    client.SetToken(loginResp.Data.Token)\n    fmt.Println(\"Authentication successful!\")\n}\n</code></pre> <p>Run with:</p> <pre><code>export PIPEOPS_EMAIL=\"your-email@example.com\"\nexport PIPEOPS_PASSWORD=\"your-password\"\ngo run main.go\n</code></pre>"},{"location":"getting-started/quickstart/#using-an-existing-token","title":"Using an Existing Token","text":"<p>If you already have a token, skip the login step:</p> <pre><code>client, _ := pipeops.NewClient(\"\")\n\n// Set your existing token\nclient.SetToken(\"your-existing-token\")\n\n// Make authenticated requests\nctx := context.Background()\nprojects, _, err := client.Projects.List(ctx, nil)\n</code></pre>"},{"location":"getting-started/quickstart/#error-handling","title":"Error Handling","text":"<p>Always check for errors in production code:</p> <pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif err != nil {\n    // Check for specific error types\n    if rateLimitErr, ok := err.(*pipeops.RateLimitError); ok {\n        fmt.Printf(\"Rate limited. Retry after: %v\\n\", rateLimitErr.RetryAfter)\n    } else {\n        log.Printf(\"API error: %v\\n\", err)\n    }\n    return\n}\n\n// Check HTTP status\nif resp.StatusCode != 200 {\n    log.Printf(\"Unexpected status code: %d\\n\", resp.StatusCode)\n}\n\n// Use the data\nfmt.Printf(\"Projects: %+v\\n\", projects)\n</code></pre>"},{"location":"getting-started/quickstart/#context-and-timeouts","title":"Context and Timeouts","text":"<p>Use contexts to control request cancellation and timeouts:</p> <pre><code>// Timeout after 5 seconds\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\nprojects, _, err := client.Projects.List(ctx, nil)\nif err == context.DeadlineExceeded {\n    log.Println(\"Request timed out\")\n}\n</code></pre>"},{"location":"getting-started/quickstart/#complete-working-example","title":"Complete Working Example","text":"<p>See the examples/basic directory for a complete working example you can run locally.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Learn about all configuration options</li> <li>Authentication - Explore authentication methods</li> <li>API Services - Discover all available services</li> <li>Error Handling - Handle errors effectively</li> </ul>"},{"location":"reference/client/","title":"Client Reference","text":"<p>Complete reference for the Client type.</p>"},{"location":"reference/client/#client-type","title":"Client Type","text":"<pre><code>type Client struct {\n    // HTTP client used for requests\n    client *http.Client\n\n    // Base URL for API requests\n    BaseURL *url.URL\n\n    // User agent string\n    UserAgent string\n\n    // Services\n    Auth         *AuthService\n    OAuth        *OAuthService\n    Projects     *ProjectService\n    Servers      *ServerService\n    // ... other services\n}\n</code></pre>"},{"location":"reference/client/#constructor","title":"Constructor","text":""},{"location":"reference/client/#newclient","title":"NewClient","text":"<pre><code>func NewClient(baseURL string, options ...ClientOption) (*Client, error)\n</code></pre> <p>Creates a new PipeOps API client.</p> <p>Parameters: - <code>baseURL</code> - API base URL (use \"\" for default) - <code>options</code> - Configuration options</p> <p>Example: <pre><code>client, err := pipeops.NewClient(\"\",\n    pipeops.WithTimeout(30*time.Second),\n    pipeops.WithMaxRetries(3),\n)\n</code></pre></p>"},{"location":"reference/client/#methods","title":"Methods","text":""},{"location":"reference/client/#settoken","title":"SetToken","text":"<pre><code>func (c *Client) SetToken(token string)\n</code></pre> <p>Set authentication token for requests.</p>"},{"location":"reference/client/#sethttpclient","title":"SetHTTPClient","text":"<pre><code>func (c *Client) SetHTTPClient(httpClient *http.Client)\n</code></pre> <p>Set custom HTTP client.</p>"},{"location":"reference/client/#configuration-options","title":"Configuration Options","text":""},{"location":"reference/client/#withtimeout","title":"WithTimeout","text":"<pre><code>func WithTimeout(timeout time.Duration) ClientOption\n</code></pre>"},{"location":"reference/client/#withmaxretries","title":"WithMaxRetries","text":"<pre><code>func WithMaxRetries(maxRetries int) ClientOption\n</code></pre>"},{"location":"reference/client/#withhttpclient","title":"WithHTTPClient","text":"<pre><code>func WithHTTPClient(httpClient *http.Client) ClientOption\n</code></pre>"},{"location":"reference/client/#withuseragent","title":"WithUserAgent","text":"<pre><code>func WithUserAgent(userAgent string) ClientOption\n</code></pre>"},{"location":"reference/client/#withlogger","title":"WithLogger","text":"<pre><code>func WithLogger(logger Logger) ClientOption\n</code></pre>"},{"location":"reference/client/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide</li> </ul>"},{"location":"reference/errors/","title":"Errors Reference","text":"<p>Error types used by the SDK.</p>"},{"location":"reference/errors/#errorresponse","title":"ErrorResponse","text":"<pre><code>type ErrorResponse struct {\n    Response *http.Response\n    Status   string              `json:\"status\"`\n    Message  string              `json:\"message\"`\n    Errors   map[string][]string `json:\"errors,omitempty\"`\n}\n</code></pre> <p>General API error response.</p>"},{"location":"reference/errors/#ratelimiterror","title":"RateLimitError","text":"<pre><code>type RateLimitError struct {\n    Response   *http.Response\n    RetryAfter time.Duration\n}\n</code></pre> <p>Returned when rate limited (HTTP 429).</p>"},{"location":"reference/errors/#usage","title":"Usage","text":"<pre><code>projects, resp, err := client.Projects.List(ctx, nil)\nif err != nil {\n    // Check for rate limit\n    if rateLimitErr, ok := err.(*pipeops.RateLimitError); ok {\n        time.Sleep(rateLimitErr.RetryAfter)\n        // Retry\n    }\n\n    // Check for general error\n    if errResp, ok := err.(*pipeops.ErrorResponse); ok {\n        log.Printf(\"API error: %s\", errResp.Message)\n    }\n}\n</code></pre>"},{"location":"reference/errors/#see-also","title":"See Also","text":"<ul> <li>Error Handling</li> </ul>"},{"location":"reference/types/","title":"Types Reference","text":"<p>Common types used throughout the SDK.</p>"},{"location":"reference/types/#timestamp","title":"Timestamp","text":"<pre><code>type Timestamp struct {\n    time.Time\n}\n</code></pre> <p>Handles various date/time formats from the API.</p>"},{"location":"reference/types/#user","title":"User","text":"<pre><code>type User struct {\n    ID            string     `json:\"id,omitempty\"`\n    UUID          string     `json:\"uuid,omitempty\"`\n    Email         string     `json:\"email,omitempty\"`\n    FirstName     string     `json:\"first_name,omitempty\"`\n    LastName      string     `json:\"last_name,omitempty\"`\n    IsActive      bool       `json:\"is_active,omitempty\"`\n    EmailVerified bool       `json:\"email_verified,omitempty\"`\n    CreatedAt     *Timestamp `json:\"created_at,omitempty\"`\n    UpdatedAt     *Timestamp `json:\"updated_at,omitempty\"`\n}\n</code></pre>"},{"location":"reference/types/#project","title":"Project","text":"<pre><code>type Project struct {\n    ID            string     `json:\"id,omitempty\"`\n    UUID          string     `json:\"uuid,omitempty\"`\n    Name          string     `json:\"name,omitempty\"`\n    Description   string     `json:\"description,omitempty\"`\n    Status        string     `json:\"status,omitempty\"`\n    ServerID      string     `json:\"server_id,omitempty\"`\n    EnvironmentID string     `json:\"environment_id,omitempty\"`\n    Repository    string     `json:\"repository,omitempty\"`\n    Branch        string     `json:\"branch,omitempty\"`\n    CreatedAt     *Timestamp `json:\"created_at,omitempty\"`\n    UpdatedAt     *Timestamp `json:\"updated_at,omitempty\"`\n}\n</code></pre>"},{"location":"reference/types/#server","title":"Server","text":"<pre><code>type Server struct {\n    ID       string     `json:\"id,omitempty\"`\n    UUID     string     `json:\"uuid,omitempty\"`\n    Name     string     `json:\"name,omitempty\"`\n    Provider string     `json:\"provider,omitempty\"`\n    Region   string     `json:\"region,omitempty\"`\n    Status   string     `json:\"status,omitempty\"`\n    CreatedAt *Timestamp `json:\"created_at,omitempty\"`\n}\n</code></pre>"},{"location":"reference/types/#see-also","title":"See Also","text":"<ul> <li>API Services</li> </ul>"}]}